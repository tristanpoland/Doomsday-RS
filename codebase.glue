$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
doomsday
ddayconfig.yml
!docs/ddayconfig.yml
doomsday-darwin-amd64
doomsday-darwin-arm64
doomsday-darwin
doomsday-linux
doomsday-linux-amd64
!client/doomsday
node_modules

$$--GLUE--$$
.\Dockerfile
$$--GLUE--$$
FROM golang:1.14 as build

ADD . /go/src/doomsdayproject/doomsday/
RUN cd /go/src/doomsdayproject/doomsday/ \
  && go get ./... \
  && make all

FROM ubuntu:18.04
EXPOSE 8111/tcp
COPY --from=build /go/src/doomsdayproject/doomsday/doomsday-linux /doomsday/doomsday
ADD ./docker/ /doomsday/
RUN adduser --system --disabled-password --no-create-home --home /doomsday/ doomsday \
  && chown -R doomsday /doomsday && chmod 755 /doomsday/entrypoint.sh
USER doomsday
CMD ["/doomsday/entrypoint.sh"]

$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>

$$--GLUE--$$
.\Makefile
$$--GLUE--$$
BUILD_TARGET ?= cmd/*.go
APP_NAME := doomsday
OUTPUT_NAME ?= $(APP_NAME)
SHELL := $(shell which bash)
COMMIT_HASH := $(shell git log --pretty='format:%h' -n 1)
DIRTY_LINE := $(shell git diff --shortstat 2> /dev/null | tail -n1)
ifneq ("$(DIRTY_LINE)", "")
  DIRTY := +
endif
VERSION ?= development
LDFLAGS := -X "github.com/doomsday-project/doomsday/version.Version=$(VERSION)-$(COMMIT_HASH)$(DIRTY)"
BUILD := go build -v -ldflags='$(LDFLAGS)' -o $(OUTPUT_NAME) $(BUILD_TARGET)

.PHONY: build server darwin darwin-amd64 darwin-arm64 linux linux-amd64 embed tsc all clean
.DEFAULT: build

build: embed server

server:
	@echo $(VERSION)-$(COMMIT_HASH)$(DIRTY)
	GOOS=$(GOOS) GOARCH=$(GOARCH) VERSION=$(VERSION) $(BUILD)

darwin: darwin-amd64 darwin-arm64

darwin-amd64:
	GOOS=darwin GOARCH=amd64 OUTPUT_NAME=$(APP_NAME)-darwin-amd64 $(MAKE) server

darwin-arm64:
	GOOS=darwin GOARCH=arm64 OUTPUT_NAME=$(APP_NAME)-darwin-arm64 $(MAKE) server

linux: linux-amd64

linux-amd64:
	GOOS=linux GOARCH=amd64 OUTPUT_NAME=$(APP_NAME)-linux-amd64 $(MAKE) server

all: embed darwin linux

embed: tsc
	GOOS="" GOARCH="" go run web/embed/main.go web/embed/mappings.yml

tsc:
	cd web && npm install
	tsc --project web/tsconfig.json

clean:
	rm -f $(APP_NAME) $(APP_NAME)-darwin-amd64 $(APP_NAME)-darwin-arm64 $(APP_NAME)-linux-amd64

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Doomsday

Doomsday is a server (and also a CLI) which can be configured to track
certificates from different storage backends (Vault, Credhub, Pivotal
Ops Manager, or actual websites) and provide a tidy view into when certificates
will expire. Doomsday provides no automation for renewal - Doomsday simply
provides the information required for maintainers to take action.

## Server configuration

Create a configuration manifest and start the server against it with
`doomsday server -m <pathtomanifest>`

The manifest should be written in YAML. An example schema with documentation
can be found at [docs/ddayconfig.yml](docs/ddayconfig.yml)

## Pushing to CloudFoundry

You'll want to make a directory that has three
files.

* A binary of doomsday for the correct operating system
* A doomsday server configuration manifest
* A cf application manifest for deploying doomsday

The binary can be found at the releases page for this Github repo.

An example manifest can be found at
[docs/ddayconfig.yml](docs/ddayconfig.yml). Omit the `server.port` property
from the manifest. This will cause the server to look for the `PORT` environment
variable for which port to have the API listen on (which is what CF wants).

The cf application manifest will probably look something like this,
assuming that your binary is called `doomsday`, and your configuration
manifest is called `doomsdayconf.yml`.

```yml
---
applications:
  - name: doomsday
    memory: 256M
    instances: 1
    command: ./doomsday server -m doomsdayconf.yml
    buildpack: binary_buildpack
```

Then, if your cf app manifest is called `manifest.yml`, run

```sh
cf push -f manifest.yml
```

## Development Notes

Make sure your GOPATH has your $HOME/go and this directory in its settings.
We are assuming the GOROOT has been set when you installed the go package.

```sh
export GOPATH="$HOME/go:$PWD"
```


$$--GLUE--$$
.\client\doomsday\client.go
$$--GLUE--$$
package doomsday

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httputil"
	"net/url"
	"time"

	"github.com/doomsday-project/doomsday/server/auth"
)

type Client struct {
	Client *http.Client
	URL    url.URL
	Token  string
	Trace  io.Writer
}

func (c *Client) doRequest(
	method, path string,
	input, output interface{}) error {
	var client = c.Client
	if c.Client == nil {
		client = http.DefaultClient
	}
	var reqBody io.Reader
	if input != nil {
		reqBody = &bytes.Buffer{}
		jEncoder := json.NewEncoder(reqBody.(*bytes.Buffer))
		err := jEncoder.Encode(&input)
		if err != nil {
			panic("Could not encode object for request body")
		}
	}

	req, err := http.NewRequest(method, fmt.Sprintf("%s%s", c.URL.String(), path), reqBody)
	if err != nil {
		return err
	}
	req.Header.Set("X-Doomsday-Token", c.Token)

	if c.Trace != nil {
		dump, err := httputil.DumpRequest(req, true)
		if err != nil {
			return err
		}
		_, err = c.Trace.Write(dump)
		if err != nil {
			return err
		}
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if c.Trace != nil {
		dump, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return err
		}
		_, err = c.Trace.Write(dump)
		if err != nil {
			return err
		}
	}

	if (resp.StatusCode / 100) != 2 {
		return parseError(resp.StatusCode)
	}

	if output != nil {
		jDecoder := json.NewDecoder(resp.Body)
		err := jDecoder.Decode(&output)
		return err
	}

	return nil
}

//UserpassAuth attempts to authenticate with the doomsday server. If successful,
// the response is stored into the client
func (c *Client) UserpassAuth(username, password string) error {
	output := struct {
		Token string `json:"token"`
	}{}

	err := c.doRequest("POST", "/v1/auth", map[string]string{
		"username": username,
		"password": password,
	}, &output)

	c.Token = output.Token
	return err
}

type CacheItem struct {
	Paths      []CacheItemPath `json:"paths"`
	CommonName string          `json:"common_name"`
	NotAfter   int64           `json:"not_after"`
}

type CacheItemPath struct {
	Backend  string `json:"backend"`
	Location string `json:"location"`
}

type CacheItems []CacheItem
type CacheItemFilter struct {
	Beyond *time.Duration
	Within *time.Duration
}

//Filter only works if the given CacheItems is sorted by NotAfter
func (c CacheItems) Filter(filter CacheItemFilter) CacheItems {
	ret := make(CacheItems, 0, len(c))
	for _, v := range c {
		ret = append(ret, v)
	}

	if filter.Beyond != nil {
		cutoff := time.Now().Add(*filter.Beyond)
		for i, v := range ret {
			if cutoff.Before(time.Unix(v.NotAfter, 0)) {
				ret = ret[i:]
				break
			}
		}
	}

	if filter.Within != nil {
		cutoff := time.Now().Add(*filter.Within)
		for i, v := range ret {
			if cutoff.Before(time.Unix(v.NotAfter, 0)) {
				ret = ret[:i]
				break
			}
		}
	}

	return ret
}

type GetCacheResponse struct {
	Content CacheItems `json:"content"`
}

//GetCache gets the cache list
func (c *Client) GetCache() (CacheItems, error) {
	resp := GetCacheResponse{}
	err := c.doRequest("GET", "/v1/cache", nil, &resp)
	return resp.Content, err
}

//RefreshCache makes a request to asynchronously refresh the server cache
func (c *Client) RefreshCache() error {
	return c.doRequest("POST", "/v1/cache/refresh", nil, nil)
}

type InfoResponse struct {
	Version  string        `json:"version"`
	AuthType auth.AuthType `json:"auth_type"`
}

func (c *Client) Info() (*InfoResponse, error) {
	resp := InfoResponse{}
	err := c.doRequest("GET", "/v1/info", nil, &resp)
	return &resp, err
}

type GetSchedulerResponse struct {
	Running []GetSchedulerTask   `json:"running"`
	Pending []GetSchedulerTask   `json:"pending"`
	Workers []GetSchedulerWorker `json:"workers"`
}

type GetSchedulerTask struct {
	At       int64  `json:"at"`
	Backend  string `json:"backend"`
	Reason   string `json:"reason"`
	Kind     string `json:"kind"`
	ID       uint   `json:"id"`
	State    string `json:"state"`
	WorkerID int    `json:"worker_id"`
}

type GetSchedulerWorker struct {
	ID      uint   `json:"id"`
	State   string `json:"state"`
	StateAt int64  `json:"state_at"`
}

func (c *Client) GetSchedulerState() (*GetSchedulerResponse, error) {
	resp := GetSchedulerResponse{}
	err := c.doRequest("GET", "/v1/scheduler", nil, &resp)
	return &resp, err
}

$$--GLUE--$$
.\client\doomsday\errors.go
$$--GLUE--$$
package doomsday

import "fmt"

type ErrUnauthorized struct {
	message string
}

func (e *ErrUnauthorized) Error() string {
	return e.message
}

type ErrBadRequest struct {
	message string
}

func (e *ErrBadRequest) Error() string {
	return e.message
}

type ErrInternalServer struct {
	message string
}

func (e *ErrInternalServer) Error() string {
	return e.message
}

func parseError(code int) (err error) {
	switch code {
	case 400:
		err = &ErrBadRequest{message: "400 - Bad Request"}
	case 401:
		err = &ErrUnauthorized{message: "401 - Unauthorized"}
	case 500:
		err = &ErrInternalServer{message: "500 - Internal Server Error"}
	default:
		err = fmt.Errorf("%d - An error occurred", code)
	}
	return err
}

$$--GLUE--$$
.\cmd\cli_config.go
$$--GLUE--$$
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/olekukonko/tablewriter"
	"github.com/starkandwayne/goutils/ansi"

	yaml "gopkg.in/yaml.v2"
)

type CLIConfig struct {
	Current string      `yaml:"current"`
	Targets []CLITarget `yaml:"targets"`
}

func (c CLIConfig) CurrentTarget() *CLITarget {
	return c.Find(c.Current)
}

func (c CLIConfig) Find(name string) *CLITarget {
	for _, target := range c.Targets {
		if target.Name == name {
			return &target
		}
	}

	return nil
}

func (c *CLIConfig) SetCurrent(name string) error {
	if c.Find(name) == nil {
		return fmt.Errorf("No target with name `%s' exists", name)
	}

	c.Current = name
	target = c.Find(c.Current)
	return nil
}

func (c *CLIConfig) Add(target CLITarget) error {
	for c.Find(target.Name) != nil {
		c.Delete(target.Name)
	}

	c.Targets = append(c.Targets, target)
	return nil
}

func (c *CLIConfig) Delete(name string) {
	for i, target := range c.Targets {
		if target.Name == name {
			c.Targets[i], c.Targets[len(c.Targets)-1] = c.Targets[len(c.Targets)-1], c.Targets[i]
			c.Targets = c.Targets[:len(c.Targets)-1]
			break
		}
	}
}

type CLITarget struct {
	Name       string `yaml:"name"`
	Address    string `yaml:"address"`
	Token      string `yaml:"token"`
	SkipVerify bool   `yaml:"skip_verify"`
}

func (c *CLITarget) String() string {
	buf := bytes.NewBuffer([]byte("\n"))
	table := tablewriter.NewWriter(buf)

	table.SetAutoFormatHeaders(false)
	table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	table.SetRowLine(true)

	table.SetHeader([]string{"NAME", c.Name})
	table.Append([]string{"ADDRESS", c.Address})
	skipVerify := fmt.Sprintf("%t", c.SkipVerify)
	if c.SkipVerify {
		skipVerify = ansi.Sprintf("@R{%t}", c.SkipVerify)
	}
	table.Append([]string{"SKIP VERIFY", skipVerify})

	table.SetHeaderColor(tablewriter.Color(tablewriter.FgMagentaColor, tablewriter.Bold), tablewriter.Color(tablewriter.BgBlackColor))
	table.SetColumnColor(tablewriter.Color(tablewriter.FgMagentaColor, tablewriter.Bold), tablewriter.Color(tablewriter.BgBlackColor))
	table.Render()
	return buf.String()
}

func loadConfig(path string) (*CLIConfig, error) {
	file, err := os.OpenFile(path, os.O_CREATE|os.O_RDONLY, 0600)
	if err != nil {
		return nil, fmt.Errorf("Could not open config at `%s': %s", path, err)
	}
	defer file.Close()

	fileContents, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("Could not read from config (%s): %s", path, err)
	}

	conf := CLIConfig{}
	err = yaml.Unmarshal(fileContents, &conf)
	if err != nil {
		return nil, fmt.Errorf("Could not parse config (%s) as YAML: %s", path, err)
	}

	return &conf, nil
}

func (c *CLIConfig) saveConfig(path string) error {
	file, err := os.OpenFile(path, os.O_TRUNC|os.O_WRONLY, 0600)
	if err != nil {
		return fmt.Errorf("Could not open config file at `%s' for writing: %s", path, err)
	}

	jEncoder := yaml.NewEncoder(file)
	err = jEncoder.Encode(&c)
	if err != nil {
		return fmt.Errorf("Could not write YAML to file at `%s': %s", path, err)
	}

	return nil
}

$$--GLUE--$$
.\cmd\command.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"
)

type command interface {
	Run() error
}

var cmdIndex = map[string]command{}

func init() {

}

//GLOBALS
var (
	configPath = app.Flag("config", "Path to the config file").
			Short('c').
			Default(fmt.Sprintf("%s/.dday", os.Getenv("HOME"))).String()
	trace = app.Flag("trace", "Show HTTP trace").
		Short('T').Bool()
)

$$--GLUE--$$
.\cmd\dashboard.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/olekukonko/tablewriter"
)

type dashboardCmd struct {
}

func (d *dashboardCmd) Run() error {
	results, err := client.GetCache()
	if err != nil {
		return err
	}

	expiredBound := time.Duration(0)
	expired := results.Filter(doomsday.CacheItemFilter{
		Within: &expiredBound,
	})

	if len(expired) > 0 {
		header := tablewriter.NewWriter(os.Stdout)
		header.SetHeader([]string{"EXPIRED"})
		header.SetHeaderColor(tablewriter.Colors{
			tablewriter.Bold,
			tablewriter.BgBlackColor,
			tablewriter.FgHiRedColor,
		})
		header.SetHeaderLine(false)
		header.Render()

		t := tablewriter.NewWriter(os.Stdout)
		t.SetBorder(false)
		t.SetRowLine(true)
		t.SetAutoWrapText(false)
		t.SetReflowDuringAutoWrap(false)

		t.SetHeader([]string{"Common Name", "Path"})

		for _, v := range expired {
			t.Append([]string{v.CommonName, genPathStr(v)})
		}
		t.Render()
	}

	within3DaysBound := time.Duration(time.Hour * 24 * 3)
	within3Days := results.Filter(doomsday.CacheItemFilter{
		Beyond: &expiredBound,
		Within: &within3DaysBound,
	})

	if len(within3Days) > 0 {
		header := tablewriter.NewWriter(os.Stdout)
		header.SetHeader([]string{"WITHIN 3 DAYS"})
		header.SetHeaderColor(tablewriter.Colors{
			tablewriter.Bold,
			tablewriter.BgBlackColor,
			tablewriter.FgHiYellowColor,
		})
		header.SetHeaderLine(false)
		header.Render()

		printList(within3Days)
	}

	within2WeeksBound := time.Duration(time.Hour * 24 * 7 * 2)
	within2Weeks := results.Filter(doomsday.CacheItemFilter{
		Beyond: &within3DaysBound,
		Within: &within2WeeksBound,
	})

	if len(within2Weeks) > 0 {
		header := tablewriter.NewWriter(os.Stdout)
		header.SetHeader([]string{"WITHIN 2 WEEKS"})
		header.SetHeaderColor(tablewriter.Colors{
			tablewriter.Bold,
			tablewriter.BgBlackColor,
			tablewriter.FgHiGreenColor,
		})
		header.SetHeaderLine(false)
		header.Render()

		printList(within2Weeks)
	}

	within4WeeksBound := time.Duration(time.Hour * 24 * 7 * 4)
	within4Weeks := results.Filter(doomsday.CacheItemFilter{
		Beyond: &within2WeeksBound,
		Within: &within4WeeksBound,
	})

	if len(within4Weeks) > 0 {
		header := tablewriter.NewWriter(os.Stdout)
		header.SetHeader([]string{"WITHIN 4 WEEKS"})
		header.SetHeaderColor(tablewriter.Colors{
			tablewriter.Bold,
			tablewriter.BgBlackColor,
			tablewriter.FgHiBlueColor,
		})
		header.SetHeaderLine(false)
		header.Render()

		printList(within4Weeks)
	}

	withinDash := results.Filter(doomsday.CacheItemFilter{
		Within: &within4WeeksBound,
	})

	if len(withinDash) == 0 {
		fmt.Println("Could not find any certs which expire soon")
	}

	return nil
}

$$--GLUE--$$
.\cmd\info.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"

	"github.com/olekukonko/tablewriter"
)

type infoCmd struct{}

func (i *infoCmd) Run() error {
	info, err := client.Info()
	if err != nil {
		return err
	}

	fmt.Println("")
	table := tablewriter.NewWriter(os.Stdout)

	table.SetAutoFormatHeaders(false)
	table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	table.SetRowLine(true)

	table.SetHeader([]string{"VERSION", info.Version})
	table.Append([]string{"AUTH METHOD", string(info.AuthType)})

	table.SetHeaderColor(tablewriter.Color(tablewriter.FgMagentaColor, tablewriter.Bold), tablewriter.Color(tablewriter.BgBlackColor))
	table.SetColumnColor(tablewriter.Color(tablewriter.FgMagentaColor, tablewriter.Bold), tablewriter.Color(tablewriter.BgBlackColor))
	table.Render()
	fmt.Println("")

	return nil
}

$$--GLUE--$$
.\cmd\list.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/doomsday-project/doomsday/duration"
	"github.com/olekukonko/tablewriter"
	"github.com/starkandwayne/goutils/ansi"
)

type listCmd struct {
	Beyond *string
	Within *string
}

func (s *listCmd) Run() error {
	results, err := client.GetCache()
	if err != nil {
		return err
	}

	filter := doomsday.CacheItemFilter{}

	//Parse the durations
	if s.Beyond != nil && *s.Beyond != "" {
		dur, err := duration.Parse(*s.Beyond)
		if err != nil {
			return fmt.Errorf("When parsing beyond duration: %s", err)
		}

		filter.Beyond = &dur
	}

	if s.Within != nil && *s.Within != "" {
		dur, err := duration.Parse(*s.Within)
		if err != nil {
			return fmt.Errorf("When parsing within duration: %s", err)
		}

		filter.Within = &dur
	}

	results = results.Filter(filter)

	//Printing
	fmt.Println("")
	printList(results)

	return nil
}

func printList(items doomsday.CacheItems) {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetBorder(false)
	table.SetRowLine(true)
	table.SetAutoWrapText(false)
	table.SetReflowDuringAutoWrap(false)
	table.SetHeader([]string{"Common Name", "Expiry", "Path"})
	for _, result := range items {
		expiresIn := time.Until(time.Unix(result.NotAfter, 0))

		expStr := ansi.Sprintf("@R{EXPIRED}")
		if expiresIn > 0 {
			expStr = duration.Format(expiresIn)
		}
		table.Append([]string{
			result.CommonName,
			expStr,
			genPathStr(result),
		})
	}
	table.Render()
}

func genPathStr(item doomsday.CacheItem) string {
	fmtPaths := []string{}
	for i := 0; i < len(item.Paths); i++ {
		backendStr := item.Paths[i].Backend + "->"
		if i != 0 && item.Paths[i].Backend == item.Paths[i-1].Backend {
			b := make([]byte, len(backendStr))
			for j := range b {
				b[j] = 0x20
			}
			backendStr = string(b)
		}
		fmtPaths = append(fmtPaths, fmt.Sprintf("%s%s", backendStr, item.Paths[i].Location))
	}

	ret := strings.Join(fmtPaths, "\n")
	return ret
}

$$--GLUE--$$
.\cmd\login.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"

	"github.com/doomsday-project/doomsday/server/auth"
	"golang.org/x/crypto/ssh/terminal"
)

type loginCmd struct {
	Username *string
	Password *string
}

func (l *loginCmd) Run() error {
	info, err := client.Info()
	if err != nil {
		return err
	}
	var token string
	switch info.AuthType {
	case auth.AuthNop:
		token, err = l.handleNop()
	case auth.AuthUserpass:
		token, err = l.handleUserpass()
	default:
		err = fmt.Errorf("Unknown auth method: %s", info.AuthType)
	}
	if err != nil {
		return err
	}

	toAdd := *cliConf.CurrentTarget()
	toAdd.Token = token
	cliConf.Add(toAdd)

	fmt.Println("")
	fmt.Printf("Successfully authenticated to `%s'\n", toAdd.Name)
	return nil
}

func (l *loginCmd) handleNop() (string, error) {
	return "", fmt.Errorf("This doomsday server does not use authentication")
}

func (l *loginCmd) handleUserpass() (string, error) {
	if l.Username == nil || *l.Username == "" {
		fmt.Printf("Username: ")
		_, err := fmt.Scanln(l.Username)
		if err != nil {
			return "", err
		}
	}

	if l.Password == nil || *l.Password == "" {
		fmt.Printf("Password: ")
		tmpPass, err := terminal.ReadPassword(int(os.Stdin.Fd()))
		fmt.Println("")
		if err != nil {
			return "", err
		}

		tmpPassStr := string(tmpPass)
		l.Password = &tmpPassStr
	}

	err := client.UserpassAuth(*l.Username, *l.Password)
	if err != nil {
		return "", fmt.Errorf("Could not authenticate: %s", err)
	}

	return client.Token, nil
}

$$--GLUE--$$
.\cmd\main.go
$$--GLUE--$$
package main

import (
	"crypto/tls"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/doomsday-project/doomsday/version"
	"github.com/starkandwayne/goutils/ansi"
	kingpin "gopkg.in/alecthomas/kingpin.v2"
)

func registerCommands(app *kingpin.Application) {
	serverCom := app.Command("server", "Start the doomsday server")
	cmdIndex["server"] = &serverCmd{
		ManifestPath: serverCom.Flag("manifest", "The path to the server manifest").
			Short('m').
			Default("ddayconfig.yml").String(),
	}

	targetCom := app.Command("target", "Manage targeted doomsday servers")
	cmdIndex["target"] = &targetCmd{
		Name:    targetCom.Arg("name", "The name of the target").String(),
		Address: targetCom.Arg("address", "The address to set for this target").String(),
		SkipVerify: targetCom.Flag("insecure", "Skip TLS cert validation for this backend").
			Short('k').Bool(),
		Delete: targetCom.Flag("delete", "Forget about the doomsday target with "+
			"the given name. Delete will not fail if the target does not exist").Short('d').Bool(),
	}

	_ = app.Command("targets", "Print out configured targets")
	cmdIndex["targets"] = &targetsCmd{}

	loginCom := app.Command("login", "Auth to the doomsday server").Alias("auth")
	cmdIndex["login"] = &loginCmd{
		Username: loginCom.Flag("username", "The username to log in as").
			Short('u').String(),
		Password: loginCom.Flag("password", "The password to log in with").
			Short('p').String(),
	}
	cmdIndex["auth"] = cmdIndex["login"]

	listCom := app.Command("list", "List the contents of the server cache")
	cmdIndex["list"] = &listCmd{
		Beyond: listCom.Flag("beyond", "Restrict to certs that expire in longer than the given duration").
			Short('b').PlaceHolder("1y2d3h4m").String(),
		Within: listCom.Flag("within", "Restrict to certs that expire in less than the given duration").
			Short('w').PlaceHolder("1y2d3h4m").String(),
	}

	_ = app.Command("dashboard", "See your impending doom").Alias("dash")
	cmdIndex["dashboard"] = &dashboardCmd{}
	cmdIndex["dash"] = cmdIndex["dashboard"]

	_ = app.Command("scheduler", "View the current state of the doomsday scheduler").Alias("sched").Hidden()
	cmdIndex["scheduler"] = &schedulerCmd{}
	cmdIndex["sched"] = cmdIndex["scheduler"]

	_ = app.Command("refresh", "Refresh the servers cache")
	cmdIndex["refresh"] = &refreshCmd{}

	_ = app.Command("info", "Get info about the currently targeted doomsday server")
	cmdIndex["info"] = &infoCmd{}
}

var app = kingpin.New("doomsday", "Cert expiration tracker")
var cliConf *CLIConfig
var target *CLITarget
var client *doomsday.Client

func main() {
	registerCommands(app)
	app.Version(version.Version)
	app.VersionFlag.Short('v')
	app.HelpFlag.Short('h')

	commandName := kingpin.MustParse(app.Parse(os.Args[1:]))
	cmd, found := cmdIndex[commandName]
	if !found {
		panic(fmt.Sprintf("Unregistered command %s", commandName))
	}

	if _, isServerCommand := cmd.(*serverCmd); !isServerCommand {
		var err error
		cliConf, err = loadConfig(*configPath)
		if err != nil {
			bailWith("Could not load CLI config from `%s': %s", *configPath, err)
		}

		target = cliConf.CurrentTarget()
	}

	switch cmd.(type) {
	case *serverCmd, *targetCmd, *targetsCmd:
	default:
		target = cliConf.CurrentTarget()
		if target == nil {
			bailWith("No doomsday server is currently targeted")
		}

		u, err := url.Parse(target.Address)
		if err != nil {
			bailWith("Could not parse target address as URL")
		}

		var traceWriter io.Writer
		if trace != nil && *trace {
			traceWriter = os.Stderr
		}

		client = &doomsday.Client{
			URL:   *u,
			Token: target.Token,
			Client: &http.Client{
				Transport: &http.Transport{
					TLSClientConfig: &tls.Config{
						InsecureSkipVerify: target.SkipVerify,
					},
				},
			},
			Trace: traceWriter,
		}
	}

	err := cmd.Run()
	if err != nil {
		if _, is401 := err.(*doomsday.ErrUnauthorized); is401 {
			err = fmt.Errorf("Not authenticated. Please log in with `doomsday login'")
		}
		bailWith(err.Error())
	}

	err = cliConf.saveConfig(*configPath)
	if err != nil {
		bailWith("Could not save config: %s", err)
	}
}

func bailWith(f string, a ...interface{}) {
	ansi.Fprintf(os.Stderr, fmt.Sprintf("@R{%s}\n", f), a...)
	os.Exit(1)
}

$$--GLUE--$$
.\cmd\refresh.go
$$--GLUE--$$
package main

type refreshCmd struct{}

func (r *refreshCmd) Run() error {
	return client.RefreshCache()
}

$$--GLUE--$$
.\cmd\scheduler.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/olekukonko/tablewriter"
)

type schedulerCmd struct{}

func (*schedulerCmd) Run() error {
	state, err := client.GetSchedulerState()
	if err != nil {
		return err
	}

	header := tablewriter.NewWriter(os.Stdout)
	header.SetHeader([]string{"WORKERS"})
	header.SetHeaderLine(false)
	header.Render()

	printWorkerList(state.Workers)

	header = tablewriter.NewWriter(os.Stdout)
	header.SetHeader([]string{"RUNNING"})
	header.SetHeaderLine(false)
	header.Render()

	printSchedTaskList(state.Running, true)

	header = tablewriter.NewWriter(os.Stdout)
	header.SetHeader([]string{"PENDING"})
	header.SetHeaderLine(false)
	header.Render()

	printSchedTaskList(state.Pending, false)
	return nil
}

func printWorkerList(workers []doomsday.GetSchedulerWorker) {
	fmt.Printf("\n")
	table := tablewriter.NewWriter(os.Stdout)
	table.SetBorder(false)
	table.SetRowLine(true)
	table.SetAutoWrapText(false)
	table.SetReflowDuringAutoWrap(false)
	table.SetHeader([]string{"ID", "State", "For"})
	table.SetAlignment(tablewriter.ALIGN_RIGHT)

	now := time.Now()
	for _, worker := range workers {
		timeSinceStr := now.Sub(time.Unix(worker.StateAt, 0)).Truncate(100 * time.Millisecond).String()
		table.Append([]string{strconv.FormatUint(uint64(worker.ID), 10), worker.State, timeSinceStr})
	}
	table.Render()
	fmt.Printf("\n")
}

func printSchedTaskList(tasks []doomsday.GetSchedulerTask, showWorker bool) {
	fmt.Printf("\n")
	table := tablewriter.NewWriter(os.Stdout)
	table.SetBorder(false)
	table.SetRowLine(true)
	table.SetAutoWrapText(false)
	table.SetReflowDuringAutoWrap(false)
	headers := []string{"ID", "At", "Backend", "Kind", "Reason", "State"}
	if showWorker {
		headers = append(headers, "Worker")
	}
	table.SetHeader(headers)
	table.SetAlignment(tablewriter.ALIGN_RIGHT)

	now := time.Now()
	for _, task := range tasks {
		timeUntilStr := time.Unix(task.At, 0).Sub(now).Truncate(100 * time.Millisecond).String()
		values := []string{
			strconv.FormatUint(uint64(task.ID), 10),
			timeUntilStr,
			task.Backend,
			task.Kind,
			task.Reason,
			task.State,
		}

		if showWorker {
			values = append(values, strconv.FormatInt(int64(task.WorkerID), 10))
		}

		table.Append(values)
	}
	table.Render()
	fmt.Printf("\n")
}

$$--GLUE--$$
.\cmd\server.go
$$--GLUE--$$
package main

import (
	"github.com/doomsday-project/doomsday/server"
)

type serverCmd struct {
	ManifestPath *string
}

func (s *serverCmd) Run() error {
	conf, err := server.ParseConfig(*s.ManifestPath)
	if err != nil {
		return err
	}

	return server.Start(*conf)
}

$$--GLUE--$$
.\cmd\target.go
$$--GLUE--$$
package main

import (
	"fmt"
	"net/url"
)

type targetCmd struct {
	Name       *string
	Address    *string
	SkipVerify *bool
	Delete     *bool
}

func (t *targetCmd) Run() error {
	var err error
	switch {
	case t.Delete != nil && *t.Delete:
		err = t.deleteTarget()
	case t.Name == nil || *t.Name == "":
		err = t.showTarget(cliConf.Current)
	case t.Address != nil && *t.Address != "":
		err = t.createTarget()
	case t.Name != nil && *t.Name != "":
		err = t.setTarget()
	}

	return err
}

func (t *targetCmd) setTarget() error {
	fmt.Printf("Setting target... ")
	target := cliConf.Find(*t.Name)
	if target == nil {
		return fmt.Errorf("No target with name `%s' exists", *t.Name)
	}

	cliConf.Current = *t.Name
	fmt.Println("Successfully set target")
	fmt.Println(target)
	return nil
}

func (t *targetCmd) showTarget(name string) error {
	if name == "" {
		fmt.Println("No backend currently targeted")
	} else {
		target := cliConf.Find(name)
		if target == nil {
			return fmt.Errorf("No backend with the name `%s' exists", name)
		}

		fmt.Println(target)
	}

	return nil
}

func (t *targetCmd) createTarget() error {
	fmt.Printf("Creating target... ")
	addrURL, err := url.Parse(*t.Address)
	if err != nil {
		return fmt.Errorf("Could not parse given address as URL")
	}

	if addrURL.Port() == "" {
		addrURL.Host = fmt.Sprintf("%s:8111", addrURL.Host)
	}

	if addrURL.Scheme != "http" && addrURL.Scheme != "https" {
		return fmt.Errorf("Address contains unsupported protocol `%s'", addrURL.Scheme)
	}

	err = cliConf.Add(CLITarget{
		Name:       *t.Name,
		Address:    addrURL.String(),
		SkipVerify: *t.SkipVerify,
	})
	if err != nil {
		return err
	}

	cliConf.SetCurrent(*t.Name)
	fmt.Printf("Successfully created target\n")
	fmt.Println(cliConf.Find(cliConf.Current))

	return nil
}

func (t *targetCmd) deleteTarget() error {
	if t.Name == nil || *t.Name == "" {
		return fmt.Errorf("If --delete flag is given, must provide a target name")
	}

	if t.Address != nil && *t.Address != "" {
		return fmt.Errorf("If --delete flag is given, only one argument to target can be given")
	}

	cliConf.Delete(*t.Name)
	if cliConf.Current == *t.Name {
		cliConf.Current = ""
	}
	return nil
}

$$--GLUE--$$
.\cmd\targets.go
$$--GLUE--$$
package main

import (
	"fmt"
	"os"

	"github.com/olekukonko/tablewriter"
	"github.com/starkandwayne/goutils/ansi"
)

type targetsCmd struct {
}

func (t *targetsCmd) Run() error {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Name", "Address", "Skip Verify"})
	for _, target := range cliConf.Targets {
		name := target.Name
		if target.Name == cliConf.Current {
			name = ansi.Sprintf("@G{%s}", target.Name)
		}

		skipVerify := fmt.Sprintf("%t", target.SkipVerify)
		if target.SkipVerify {
			skipVerify = ansi.Sprintf("@R{%s}", skipVerify)
		}

		table.Append([]string{name, target.Address, skipVerify})
	}

	table.SetBorder(false)
	fmt.Println("")
	table.Render()
	fmt.Println("")
	return nil
}

$$--GLUE--$$
.\docker\ddayconfig-minimal.yml
$$--GLUE--$$
#This is a minimalist doomsday server configuration manifest for testing and
# default deployments

backends:
# Checks certs of configured URLs by connecting over TCP, attempting a TLS
#   handshake, and then returning the served certificate
- type: tlsclient
  name: mytlsclient
  properties:
    # (list) A list of URLs to connect to. You should omit the scheme of the URLs
    hosts:
    # (string)
    - starkandwayne.com
    - shieldproject.io
    - genesisproject.io

$$--GLUE--$$
.\docker\entrypoint.sh
$$--GLUE--$$
#!/bin/bash
config=/doomsday/ddayconfig-minimal.yml

if [ -f "$DDAY_CONFIG_FILE" ]; then
  echo "Using specified config file: $config"
  config=$DDAY_CONFIG_FILE
fi

if [ ! -z "$DDAY_CONFIG" ]; then
  echo "Using custom config from environment..."
  echo "$DDAY_CONFIG" > "$config"
fi

/doomsday/doomsday server -m $config
$$--GLUE--$$
.\docker\readme.md
$$--GLUE--$$
# Running the Doomsday docker image

There are a few ways to run the doomsday image - the first of which is to specify no options other than the port mapping. This will spin up a doomsday server on localhost with a default config. Not exactly useful unless you want to monitor the example configs.

```bash
docker run -d -p 8111:8111 doomsdayproject/doomsday
```

There are two methods to specify your own config for the doomsday image to use, the first being mounting your config via a volume and setting the `DDAY_CONFIG_FILE` environment variable to the location of the config in the container.

For example, the below command mounts a `config` directory containing `ddayconfig.yml` into the container.

```bash
docker run -d -p 8111:8111 -v $(pwd)/config/:/doomsday/config -e DDAY_CONFIG_FILE=/doomsday/config/ddayconfig.yml doomsdayproject/doomsday
```

If you don't want to mount in the config via a file, you can also specify the entire config in an environment variable `DDAY_CONFIG`.

```bash
export DDAY_CONFIG=$(cat config/ddayconfig.yml)
docker run -d -p 8111:8111 -e DDAY_CONFIG="$DDAY_CONFIG" doomsdayproject/doomsday
```
$$--GLUE--$$
.\docs\ddayconfig.yml
$$--GLUE--$$
#This is a doomsday server configuration manifest

# backends: (list) The list of backends to ingest certificates from. Each entry
# in the backends list is a hash that looks like
#  - type: <backend-type>
#    name: <backend-name>
#    properties:
#      backend-specific-property: example
#
# type: (string, enum) Currently supported types are "vault", "opsmgr",
#   "credhub", and "tlsclient".
#
# name: (string) Attached to objects returned from the doomsday API to
#   identify where each item came from. Defaults to the backend `type` string.
#
# refresh_interval: (number) How many minutes between refreshing information from
#   this backend. Defaults to 30
#
# properties (hash): Backend-specific. You should look below for how to
#   configure each one.
backends:
# Hashicorp's Vault. https://www.vaultproject.io/
- type: vault
  name: myvault
  refresh_interval: 30
  properties:
    # (string) The URL where the Vault API is located
    address: https://127.0.0.1:443

    # (bool) (default: false) This will cause the Vault client to not check
    # for proper subject alternative names or a proper chain of trust on the
    # certificate returned by the Vault. Handy if you need it, but not
    # recommended for production use. If the certificate served by the Vault
    # is not trusted by your system, consider using the `ca_certs` option.
    #insecure_skip_verify: true

    # (string) If set, the Vault client will exclusively use the following certs
    # as its trusted certificate pool when performing a TLS handshake to the
    # targeted Vault. If this is not set, then the client will use the system's
    # trusted certificate pool.
    #ca_certs: |
    #  -----BEGIN CERTIFICATE-----
    #  I'm a cert
    #  -----END CERTIFICATE-----
    #  -----BEGIN CERTIFICATE-----
    #  I'm another cert
    #  -----END CERTIFICATE-----

    # (string) This is the path to begin looking for Vault secrets. Everything under this
    # path will be searched. Defaults to "secret/" if not present.
    base_path: "secret/"

    # (boolean) If set to true, requests to and responses from the Vault will
    # be logged to stdout. You probably only want this if you're debugging.
    #trace: true

    # (string) An optional Vault enterprise namespace to use for all Vault
    # requests.
    #namespace: "my-namespace"

    # (hash) Options for authorizing to Vault
    # Must either provide "token" for Token auth or "role_id" and "secret_id" for AppRole
    # If a token is given, it should either have no expiry or be renewable.
    # If AppRole credentials are given, the token that is generated should be renewable.
    auth:
      # (string) A Vault authentication token.
      token: 01234567-89ab-cdef-0123-456789abcdef

      # (string) An AppRole role ID
      # role_id: 01234567-89ab-cdef-0123-456789abcdef

      # (string): An AppRole secret ID
      # secret_id: s.ImaSecret

# Checks certs of configured URLs by connecting over TCP, attempting a TLS
#   handshake, and then returning the served certificate
- type: tlsclient
  name: mytlsclient
  properties:
    # (list) A list of URLs to connect to. The scheme of the URLs is optional,
    # but will be ignored. If no port is provided on a host, 443 will be used
    # by default.
    hosts:
    # (string) The hostname to track
    - starkandwayne.com
    - shieldproject.io
    - genesisproject.io

    # (number) (default: 20) How many seconds to wait before giving up on a host.
    #timeout:  20

# Pivotal Ops Manager. https://network.pivotal.io/products/ops-manager
- type: opsmgr
  name: myopsmanager
  properties:
    # (string) The URL of the Ops Manager API location.
    address: https://127.0.0.1:443

    # (bool) (default: false) This will cause the Ops Manager and UAA clients to
    # not check for proper subject alternative names or a proper chain of trust
    # on the certificate returned by those respective servers. Handy if you
    # need it, but not recommended for production use. If the certificate
    # served by the Ops Manager and/or UAA is not trusted by your system,
    # consider using the `ca_certs` option.
    #insecure_skip_verify: true

    # (string) If set, the Ops Manager and UAA client will exclusively use the
    # following certs as its trusted certificate pool when performing a TLS
    # handshake to the targeted Ops Manager and associated UAA servers. If this
    # is not set, then the client will use the system's trusted certificate
    # pool.
    #ca_certs: |
    #  -----BEGIN CERTIFICATE-----
    #  I'm a cert
    #  -----END CERTIFICATE-----
    #  -----BEGIN CERTIFICATE-----
    #  I'm another cert
    #  -----END CERTIFICATE-----

    # (hash) Options for authorizing to the UAA attached to your Ops Manager
    auth:
      # (string) The grant type with which you are going to authenticate to the UAA
      # One of "password" or "client_credentials". If it's "client_credentials",
      # provide "client_id" and "client_secret". If it's "password", then provide
      # "client_id", "client_secret", "username", and "password"
      grant_type: password

      # (string) The id of the OAuth client
      client_id: opsman

      # (string) The secret of the OAuth client
      client_secret: ""

      # (string) The username of the user to use (if doing password grant type)
      username: admin

      # (string) The password of the user to use (if doing password grant type)
      password: password

# Pivotal's Credhub. https://github.com/cloudfoundry-incubator/credhub
# An implementation of the BOSH Config Server API.
- type: credhub
  name: mycredhub
  properties:
    # (string) The URL where the Credhub API is located
    address: https://127.0.0.1:8844

    # (bool) (default: false) This will cause the CredHub and UAA clients to
    # not check for proper subject alternative names or a proper chain of trust
    # on the certificate returned by those respective servers. Handy if you
    # need it, but not recommended for production use. If the certificate
    # served by the Credhub and/or UAA is not trusted by your system, consider
    # using the `ca_certs` option.
    #insecure_skip_verify: true

    # (string) If set, the CredHub and UAA client will exclusively use the
    # following certs as its trusted certificate pool when performing a TLS
    # handshake to the targeted CredHub and associated UAA servers. If this is
    # not set, then the client will use the system's trusted certificate pool.
    #ca_certs: |
    #  -----BEGIN CERTIFICATE-----
    #  I'm a cert
    #  -----END CERTIFICATE-----
    #  -----BEGIN CERTIFICATE-----
    #  I'm another cert
    #  -----END CERTIFICATE-----

    # (hash) Options for authorizing to the UAA attached to your Credhub.
    # This is the same as the Ops Manager auth options. Check that out.
    auth:
      grant_type: password
      client_id: credhub_cli
      client_secret: ""
      username: credhub-cli
      password: password

# (hash) Configuration for the doomsday server API
server:
  # (number) (default: 8111)
  port: 8111
  #
  # (hash) If present, this have Doomsday's API listen with TLS.
  tls:
    # (string) An x509 certificate to serve from the API
    cert: |
      -----BEGIN CERTIFICATE-----
      fAKe
      -----END CERTIFICATE-----

    # (string) The RSA key used to sign `cert`
    key: |
      -----BEGIN RSA PRIVATE KEY-----
      fAKe
      -----END RSA PRIVATE KEY-----

  # Authentication options for the doomsday API. This may differ depending on
  # the auth type you're configuring, but at the top level, it looks like:
  #
  # type: <auth-type>
  # properties:
  #   backend: specific
  #
  # Available auth types are `none` and `userpass`
  # Userpass is an in-memory auth method that accepts a static username and
  # password and, if correct, hands back a session bearer token which expires.
  # The `none` type has no properties. You may leave the properties hash absent
  #   in that case.
  auth:
    #type: none
    type: userpass
    properties:
      # (string) The username to accept logins for
      username: admin
      # (string) The password to accept logins for
      password: password
      # (number) How many minutes a session token lasts before it is invalid.
      timeout: 30
      # (bool) If true, a session token has its validity length refreshed to
      # the configured timeout when it is used, so long as it is used while
      # still valid.
      refresh: true

notifications:
  # (string) The external URL for this doomsday server. It will be included in
  # notification messages
  doomsday_url: http://toms.laptop

  # (hash) A notification backend is something that receives notifications
  backend:
    # (string, enum) The type of notification backend.
    # Acceptable values are slack or shout.
    # Slack is... well.. Slack (slack.com)
    # Shout is github.com/jhunt/shout, a man-in-the-middle notification handler
    type: shout
    # (hash) backend-type specific notification options
    properties:
    #   (string) The url of the shout server
      url: "http://localhost:7109"
    #   (string) The username to authenticate to the shout server with
      username: admin
    #   (string) The password to authenticate to the shout server with
      password: password
    # (string) The topic to notify for (this is an identifier for this doomsday server in shout)
      topic: doomsday
    ## Notifications through incoming webhooks to Slack.
    #type: slack
    #properties:
    #  # (string) The incoming webhook to send the notifications to
    #  webhook: https://hooks.slack.com/services/ABCDEFGHI/JKLMNOPQR/StUvWxYz12345678910aBcDeFg
    #  # (bool) Whether to send notifications when there are no certs expiring soon
    #  notify_ok: false

  # (hash) A schedule for when to check/send notifications
  schedule:
    # (string, enum) The type of notification schedule.
    # Acceptable values are constant and cron
    # constant is effectively "every x minutes"
    # cron is based on cron schedules, allowing for more complex notification intervals
    type: constant
    # (hash) schedule-type-specific properties
    properties:
    #  # (number) The number of minutes to wait between notifications
      interval: 30
    #type: cron
    #properties:
    #  # A crontab spec, in the form of minute, hour, day of month, month, and day of week
    #  spec: * 12 * * *

$$--GLUE--$$
.\duration\duration.go
$$--GLUE--$$
package duration

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/starkandwayne/goutils/ansi"
)

//Format takes a duration and outputs a string representing that duration
func Format(dur time.Duration) string {
	retSlice := []string{}
	if dur >= time.Hour*24*365 {
		retSlice = append(retSlice, ansi.Sprintf("%dy", dur/(time.Hour*24*365)))
	}

	if dur >= time.Hour*24 {
		retSlice = append(retSlice, ansi.Sprintf("%dd", int64((dur.Hours())/24)%365))
	}

	if dur >= time.Hour {
		retSlice = append(retSlice, ansi.Sprintf("%dh", int64(dur.Hours())%24))
	}

	retSlice = append(retSlice, ansi.Sprintf("%dm", int64(dur.Minutes())%60))
	return strings.Join(retSlice, " ")
}

//Parse takes a duration string in the form of 1y2d3h4m and if it is properly
// formatted, the represented duration is returned. If it could not be parsed,
// an error is returned. Spaces are ignored. It is okay for any of the types
// of time to be omitted or in any particular order.
func Parse(f string) (dur time.Duration, err error) {
	var tokens []string
	tokens, err = tokenize(f)
	if err != nil {
		return
	}

	mustParseInt := func(s string) time.Duration {
		ret, err := strconv.ParseInt(s, 10, 64)
		if err != nil {
			panic("Could not parse int (should have been caught in tokenizer)")
		}

		return time.Duration(ret)
	}

	curNum := time.Duration(0)
	for _, token := range tokens {
		switch token {
		case "y":
			dur += time.Hour * 24 * 365 * curNum
		case "d":
			dur += time.Hour * 24 * curNum
		case "h":
			dur += time.Hour * curNum
		case "m":
			dur += time.Minute * curNum
		default: //number
			curNum = mustParseInt(token)
		}
	}

	return
}

func tokenize(f string) (ret []string, err error) {
	var curNum []byte
	for _, c := range f {
		switch c {
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			curNum = append(curNum, byte(c))
		case 'y', 'd', 'h', 'm':
			if len(curNum) == 0 {
				err = fmt.Errorf("Unit specifier found without number")
				goto doneTokenizing
			}

			ret = append(ret, string(curNum))
			curNum = nil
			ret = append(ret, fmt.Sprintf("%c", c))
		case ' ':
		default:
			err = fmt.Errorf("Unrecognized token found")
			goto doneTokenizing
		}
	}
doneTokenizing:

	return
}

$$--GLUE--$$
.\go.mod
$$--GLUE--$$
module github.com/doomsday-project/doomsday

go 1.18

require (
	code.cloudfoundry.org/credhub-cli v0.0.0-20191230184144-6e537b521d9d
	github.com/cloudfoundry-community/vaultkv v0.1.1
	github.com/gorilla/mux v1.7.3
	github.com/olekukonko/tablewriter v0.0.4
	github.com/pborman/uuid v1.2.0
	github.com/robfig/cron v1.2.0
	github.com/starkandwayne/goutils v0.0.0-20190115202530-896b8a6904be
	github.com/thomasmitchell/go-shout v0.0.0-20200117221442-ad6c1a8d1669
	golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2
	gopkg.in/alecthomas/kingpin.v2 v2.2.6
	gopkg.in/yaml.v2 v2.3.0
)

require (
	github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 // indirect
	github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d // indirect
	github.com/cloudfoundry/go-socks5 v0.0.0-20180221174514-54f73bdb8a8e // indirect
	github.com/cloudfoundry/socks5-proxy v0.2.0 // indirect
	github.com/google/uuid v1.0.0 // indirect
	github.com/hashicorp/go-version v0.0.0-20171129150820-4fe82ae3040f // indirect
	github.com/mattn/go-isatty v0.0.3 // indirect
	github.com/mattn/go-runewidth v0.0.7 // indirect
	golang.org/x/net v0.0.0-20200520004742-59133d7f0dd7 // indirect
	golang.org/x/sys v0.0.0-20220614162138-6c1b26c55098 // indirect
)

$$--GLUE--$$
.\go.sum
$$--GLUE--$$
code.cloudfoundry.org/credhub-cli v0.0.0-20191230184144-6e537b521d9d h1:dVWZLkpuKr9CGe9AZ7/XpZoMd9Xn6kGCp5GPxS4dRhs=
code.cloudfoundry.org/credhub-cli v0.0.0-20191230184144-6e537b521d9d/go.mod h1:502BrJv21CY4FT748a8/iLboZ7lRPp6EXn5NmJBQZiM=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 h1:JYp7IbQjafoB+tBA3gMyHYHrpOtNuDiK/uB5uXxq5wM=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d h1:UQZhZ2O0vMHr2cI+DC1Mbh0TJxzA3RcLoMsFw+aXw7E=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=
github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=
github.com/bmatcuk/doublestar v1.1.1/go.mod h1:UD6OnuiIn0yFxxA2le/rnRU1G4RaI4UvFv1sNto9p6w=
github.com/charlievieth/fs v0.0.0-20170613215519-7dc373669fa1/go.mod h1:sAoA1zHCH4FJPE2gne5iBiiVG66U7Nyp6JqlOo+FEyg=
github.com/cloudfoundry-community/vaultkv v0.1.1 h1:z4N2Ze/N5o+R3d7oWQ1n+tQMWAw+V9SDKaZyDmTX/ms=
github.com/cloudfoundry-community/vaultkv v0.1.1/go.mod h1:qjEGtHytd0cvF0m9LxA2oJlkP1k2CwRMimDeiW7iYgE=
github.com/cloudfoundry/bosh-cli v5.3.1+incompatible/go.mod h1:rzIB+e1sn7wQL/TJ54bl/FemPKRhXby5BIMS3tLuWFM=
github.com/cloudfoundry/bosh-utils v0.0.0-20180919212956-15c556314b68/go.mod h1:JCrKwetZGjxbfq1U139TZuXDBfdGLtjOEAfxMWKV/QM=
github.com/cloudfoundry/go-socks5 v0.0.0-20180221174514-54f73bdb8a8e h1:FQdRViaoDphGRfgrotl2QGsX1gbloe57dbGBS5CG6KY=
github.com/cloudfoundry/go-socks5 v0.0.0-20180221174514-54f73bdb8a8e/go.mod h1:PXmcacyJB/pJjSxEl15IU6rEIKXrhZQRzsr0UTkgNNs=
github.com/cloudfoundry/socks5-proxy v0.2.0 h1:ZRXcJxUqOyKmah+ytXh52K7m7S7SyuBacDUnd2g0ihU=
github.com/cloudfoundry/socks5-proxy v0.2.0/go.mod h1:0a+Ghg38uB86Dx+de84dFSkILTnBHzCpFMRnjHgSzi4=
github.com/cppforlife/go-patch v0.1.0/go.mod h1:67a7aIi94FHDZdoeGSJRRFDp66l9MhaAG1yGxpUoFD8=
github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/fatih/color v1.6.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/fsnotify/fsnotify v1.4.9 h1:hsms1Qyu0jgnwNXIxa+/V/PDsU6CfLf6CNO8H7IWoS4=
github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=
github.com/golang/protobuf v1.0.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.2 h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=
github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/mux v1.7.3 h1:gnP5JzjVOuiZD07fKKToCAOjS0yOpj/qPETTXCCS6hw=
github.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
github.com/hashicorp/go-version v0.0.0-20171129150820-4fe82ae3040f h1:QnRipjW3Mm+sgD+vyO87cb+1RLzoM0mGVTYClil7mQg=
github.com/hashicorp/go-version v0.0.0-20171129150820-4fe82ae3040f/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2c/go.mod h1:lADxMC39cJJqL93Duh1xhAs4I2Zs8mKS89XWXFGp9cs=
github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
github.com/jessevdk/go-flags v1.3.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=
github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
github.com/mattn/go-isatty v0.0.3 h1:ns/ykhmWi7G9O+8a448SecJU3nSMBXJfqQkl0upE1jI=
github.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
github.com/mattn/go-runewidth v0.0.7 h1:Ei8KR0497xHyKJPAv59M1dkC+rOZCMBJ+t3fZ+twI54=
github.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
github.com/nxadm/tail v1.4.4 h1:DQuhQpB1tVlglWS2hLQ5OV6B5r8aGxSrPc5Qo6uTN78=
github.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=
github.com/olekukonko/tablewriter v0.0.4 h1:vHD/YYe1Wolo78koG299f7V/VAS08c6IpCLn+Ejf/w8=
github.com/olekukonko/tablewriter v0.0.4/go.mod h1:zq6QwlOf5SlnkVbMSr5EoBv3636FWnp+qbPhuoO21uA=
github.com/onsi/ginkgo v1.4.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=
github.com/onsi/ginkgo v1.13.0 h1:M76yO2HkZASFjXL0HSoZJ1AYEmQxNJmY41Jx1zNUq1Y=
github.com/onsi/ginkgo v1.13.0/go.mod h1:+REjRxOmWfHCjfv9TTWB1jD1Frx4XydAD3zm1lskyM0=
github.com/onsi/gomega v1.3.0/go.mod h1:C1qb7wdrVGGVU+Z6iS04AVkA3Q65CEZX59MT0QO5uiA=
github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
github.com/onsi/gomega v1.10.1 h1:o0+MgICZLuZ7xjH7Vx6zS/zcu93/BEp1VwkIW1mEXCE=
github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
github.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=
github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/robfig/cron v1.2.0 h1:ZjScXvvxeQ63Dbyxy76Fj3AT3Ut0aKsyd2/tl3DTMuQ=
github.com/robfig/cron v1.2.0/go.mod h1:JGuDeoQd7Z6yL4zQhZ3OPEVHB7fL6Ka6skscFHfmt2k=
github.com/sclevine/agouti v3.0.0+incompatible/go.mod h1:b4WX9W9L1sfQKXeJf1mUTLZKJ48R1S7H23Ji7oFO5Bw=
github.com/starkandwayne/goutils v0.0.0-20190115202530-896b8a6904be h1:vV6o1C8iPioC0Ahi3e9Bs9vVPW9/YN3uwgA6EFahAws=
github.com/starkandwayne/goutils v0.0.0-20190115202530-896b8a6904be/go.mod h1:Py4V645l0xZXsyvSR6WIcsGhNQEiIFDlmJ4Xwd6UCws=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/thomasmitchell/go-shout v0.0.0-20200117221442-ad6c1a8d1669 h1:0yNQACaupniwG7arYMieo4CGe8+LTV1goOH2xAsTOfM=
github.com/thomasmitchell/go-shout v0.0.0-20200117221442-ad6c1a8d1669/go.mod h1:TU91eTbR12yCLqWKTy3ULmVZGIkneRJX1cIbJZZFCW4=
golang.org/x/crypto v0.0.0-20180319061731-c3a3ad6d03f7/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/net v0.0.0-20180319151425-92b859f39abd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20200520004742-59133d7f0dd7 h1:AeiKBIuRw3UomYXSbLy0Mc2dDLfdtbT/IVn4keq83P0=
golang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180319153314-d8e400bc7db4/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20220614162138-6c1b26c55098 h1:PgOr27OhUx2IRqGJ2RxAWI4dJQ7bi9cSrB82uzFzfUA=
golang.org/x/sys v0.0.0-20220614162138-6c1b26c55098/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.23.0 h1:4MY060fB1DLGMB/7MBTLnwQUY6+F09GEiz6SsrNqyzM=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
gopkg.in/alecthomas/kingpin.v2 v2.2.6 h1:jMFz6MfLP0/4fUyZle81rXUoxOBFi19VUFKVDOQfozc=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.0.0-20190319135612-7b8349ac747c/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

$$--GLUE--$$
.\server\auth\auth.go
$$--GLUE--$$
package auth

import (
	"fmt"
	"net/http"

	yaml "gopkg.in/yaml.v2"
)

type Authorizer interface {
	LoginHandler() http.HandlerFunc
	TokenHandler() TokenFunc
	Identifier() AuthType
}
type Config struct {
	Type       string                 `yaml:"type"`
	Properties map[string]interface{} `yaml:"properties"`
}
type TokenFunc func(http.HandlerFunc) http.HandlerFunc

type AuthType string

const (
	typeUnknown int = iota
	typeNone
	typeUserpass
)

func NewAuth(conf Config) (Authorizer, error) {
	properties, err := yaml.Marshal(&conf.Properties)
	t := resolveType(conf.Type)

	if t == typeUnknown {
		return nil, fmt.Errorf("Unrecognized auth type `%s'", conf.Type)
	}

	var c interface{}

	switch t {
	case typeNone:
		return NewNop(NopConfig{})
	case typeUserpass:
		c = &UserpassConfig{}
		err = yaml.Unmarshal(properties, c.(*UserpassConfig))
	}

	if err != nil {
		return nil, fmt.Errorf("Error when parsing backend config: %s", err)
	}

	var a Authorizer
	switch t {
	case typeUserpass:
		a, err = NewUserpass(*c.(*UserpassConfig))
	}

	return a, err
}

func resolveType(t string) int {
	switch t {
	case "", "nop", "none":
		return typeNone
	case "userpass":
		return typeUserpass
	default:
		return typeUnknown
	}
}

$$--GLUE--$$
.\server\auth\nop.go
$$--GLUE--$$
package auth

import "net/http"

//AuthNop is the identifier returned by Nop.Identifier
const AuthNop = "None"

type Nop struct{}
type NopConfig struct{}

func NewNop(_ NopConfig) (*Nop, error) { return &Nop{}, nil }

func (_ Nop) LoginHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotImplemented)
		w.Write([]byte("This doomsday server does not have authentication configured"))
	}
}

func (_ Nop) TokenHandler() TokenFunc {
	return func(fn http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			fn(w, r)
		}
	}
}

func (_ Nop) Identifier() AuthType {
	return AuthNop
}

$$--GLUE--$$
.\server\auth\userpass.go
$$--GLUE--$$
package auth

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"
	"time"

	"github.com/pborman/uuid"
)

//AuthUserpass is the identifier returned by Nop.Userpass
const AuthUserpass = "Userpass"

type sessions struct {
	table   map[string]time.Time
	lock    sync.RWMutex
	timeout time.Duration
	refresh bool
}

func (s *sessions) new() string {
	u := uuid.NewUUID()
	s.lock.Lock()
	s.table[u.String()] = time.Now().Add(s.timeout)
	s.lock.Unlock()
	return u.String()
}

func (s *sessions) validate(sessionID string) bool {
	s.lock.RLock()
	expiry, found := s.table[sessionID]
	s.lock.RUnlock()
	if found {
		if time.Now().Before(expiry) {
			if s.refresh {
				s.lock.Lock()
				s.table[sessionID] = time.Now().Add(s.timeout)
				s.lock.Unlock()
			}
			return true
		}

		s.lock.Lock()
		delete(s.table, sessionID)
		s.lock.Unlock()
	}

	return false
}

func (s *sessions) expiry(sessionID string) time.Time {
	s.lock.RLock()
	ret := s.table[sessionID]
	s.lock.RUnlock()
	return ret
}

type Userpass struct {
	username string
	password string
	sessions sessions
}

type UserpassConfig struct {
	Username string `yaml:"username"`
	Password string `yaml:"password"`
	Timeout  int    `yaml:"timeout"`
	Refresh  bool   `yaml:"refresh"`
}

func NewUserpass(conf UserpassConfig) (*Userpass, error) {
	if conf.Username == "" {
		return nil, fmt.Errorf("No username provided in userpass auth config")
	}

	if conf.Password == "" {
		return nil, fmt.Errorf("No password provided in userpass auth config")
	}

	if conf.Timeout == 0 {
		conf.Timeout = 30
	}

	return &Userpass{
		username: conf.Username,
		password: conf.Password,
		sessions: sessions{
			table:   map[string]time.Time{},
			timeout: time.Duration(conf.Timeout) * time.Minute,
			refresh: conf.Refresh,
		},
	}, nil
}

func (u *Userpass) LoginHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(500)
			return
		}

		provided := struct {
			Username string `json:"username"`
			Password string `json:"password"`
		}{}

		err = json.Unmarshal(body, &provided)
		if err != nil {
			w.WriteHeader(400)
			return
		}

		if provided.Username != u.username || provided.Password != u.password {
			w.WriteHeader(401)
			return
		}

		token := u.sessions.new()
		w.Header().Set("Content-Type", "application/json")
		http.SetCookie(w, &http.Cookie{Name: "doomsday-token", Value: token, Path: "/", Expires: u.sessions.expiry(token)})
		w.WriteHeader(200)
		w.Write([]byte(fmt.Sprintf(`{"token":"%s"}`+"\n", token)))
	}
}

func (u *Userpass) TokenHandler() TokenFunc {
	return func(fn http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			sessionID := r.Header.Get("X-Doomsday-Token")
			if sessionID == "" {
				cookie, err := r.Cookie("doomsday-token")
				if err == nil {
					sessionID = cookie.Value
				}
			}
			if u.sessions.validate(sessionID) {
				http.SetCookie(w, &http.Cookie{Name: "doomsday-token", Value: sessionID, Path: "/", Expires: u.sessions.expiry(sessionID)})
				fn(w, r)
			} else {
				w.WriteHeader(401)
			}
		}
	}
}

func (_ *Userpass) Identifier() AuthType {
	return AuthUserpass
}

$$--GLUE--$$
.\server\cache.go
$$--GLUE--$$
package server

import (
	"crypto/x509/pkix"
	"sort"
	"sync"
	"time"
)

//Cache stores all the certificate data.
type Cache struct {
	store map[string]CacheObject
	lock  *sync.RWMutex
}

func NewCache() *Cache {
	return &Cache{
		store: map[string]CacheObject{},
		lock:  &sync.RWMutex{}, //Lock for writing while the cache is being populated
	}
}

//Keys returns a list of all of the keys in the cache
func (c *Cache) Keys() []string {
	c.lock.RLock()
	defer c.lock.RUnlock()
	ret := make([]string, 0, len(c.store))
	for key := range c.store {
		ret = append(ret, key)
	}
	return ret
}

func (c *Cache) Read(key string) (CacheObject, bool) {
	c.lock.RLock()
	defer c.lock.RUnlock()
	ret, found := c.store[key]
	return ret, found
}

func (c *Cache) Store(key string, value CacheObject) {
	c.lock.Lock()
	sort.Slice(value.Paths, func(i, j int) bool { return value.Paths[i].LessThan(value.Paths[j]) })
	c.store[key] = value
	c.lock.Unlock()
}

//ApplyDiff calculates a diff between o and n, and then atomically inserts
//things new to "n" and deletes things from "o" that are no longer in "n".
func (c *Cache) ApplyDiff(o, n *Cache) {
	keysToDelete, keysToAdd := calcDiff(o, n)

	c.lock.Lock()
	for key, paths := range keysToDelete {
		c.deletePaths(key, paths)
	}

	for key, cacheObj := range keysToAdd {
		c.addNewFrom(key, cacheObj)
	}
	c.lock.Unlock()
}

func calcDiff(o, n *Cache) (toDelete map[string][]PathObject, toAdd map[string]CacheObject) {
	toDelete = map[string][]PathObject{}
	toAdd = map[string]CacheObject{}
	o.lock.RLock()
	n.lock.RLock()
	for oldKey := range o.store {
		if newCacheObj, isInNew := n.store[oldKey]; !isInNew {
			toDelete[oldKey] = o.store[oldKey].Paths
		} else {
			thisToDelete, thisToAdd := pathListDiff(o.store[oldKey].Paths, newCacheObj.Paths)
			toDelete[oldKey] = thisToDelete
			objToAdd := newCacheObj
			objToAdd.Paths = thisToAdd
			toAdd[oldKey] = objToAdd
		}
	}

	for newKey, newObj := range n.store {
		if _, isInOld := o.store[newKey]; !isInOld {
			toAdd[newKey] = newObj
		}
	}

	o.lock.RUnlock()
	n.lock.RUnlock()

	return
}

//Takes two sorted slices of PathObject (sorted according to PathObject.LessThan)
// The output lists will be sorted in the same way.
func pathListDiff(o, n []PathObject) (toDelete, toAdd []PathObject) {
	//The path lists should be sorted for this to work
	var oIdx, nIdx int
	for !(oIdx == len(o) && nIdx == len(n)) {
		switch {
		case nIdx == len(n):
			toDelete = append(toDelete, o[oIdx])
			oIdx++
		case oIdx == len(o):
			toAdd = append(toAdd, n[nIdx])
			nIdx++
		case o[oIdx] == n[nIdx]:
			oIdx++
			nIdx++
		case o[oIdx].LessThan(n[nIdx]):
			toDelete = append(toDelete, o[oIdx])
			oIdx++
		default:
			toAdd = append(toAdd, n[nIdx])
			nIdx++
		}
	}
	return
}

//toDelete must be sorted according to PathObject.LessThan
func (c *Cache) deletePaths(key string, toDelete []PathObject) {
	obj, found := c.store[key]
	if !found {
		return
	}

	workingCopy := obj.Paths
	var wIdx, dIdx int
ForLoop:
	for dIdx != len(toDelete) {
		switch {
		case wIdx == len(workingCopy):
			break ForLoop
		case workingCopy[wIdx] == toDelete[dIdx]:
			before := workingCopy[:wIdx]
			var rest []PathObject
			if wIdx+1 < len(workingCopy) {
				rest = workingCopy[wIdx+1:]
			}
			workingCopy = append(before, rest...)
			//Don't increment the index because we lost an entry
		case workingCopy[wIdx].LessThan(toDelete[dIdx]):
			wIdx++
		default:
			dIdx++
		}
	}

	if len(workingCopy) == 0 {
		delete(c.store, key)
		return
	}

	obj.Paths = workingCopy
	c.store[key] = obj
}

func (c *Cache) Merge(key string, obj CacheObject) {
	c.lock.Lock()
	c.addNewFrom(key, obj)
	c.lock.Unlock()
}

func (c *Cache) addNewFrom(key string, obj CacheObject) {
	existing, found := c.store[key]
	if !found {
		c.store[key] = obj
		return
	}

	existingLen := len(existing.Paths)
	var oIdx, eIdx int
	for oIdx != len(obj.Paths) {
		switch {
		case eIdx == existingLen:
			existing.Paths = append(existing.Paths, obj.Paths[oIdx])
			oIdx++
		case obj.Paths[oIdx] == existing.Paths[eIdx]:
			oIdx++
			eIdx++
		case obj.Paths[oIdx].LessThan(existing.Paths[eIdx]):
			eIdx++
		default:
			existing.Paths = append(existing.Paths, obj.Paths[oIdx])
			oIdx++
		}
	}

	sort.Slice(existing.Paths, func(i, j int) bool { return existing.Paths[i].LessThan(existing.Paths[j]) })
	c.store[key] = existing
}

func (c *Cache) Map() map[string]CacheObject {
	c.lock.RLock()
	defer c.lock.RUnlock()
	ret := make(map[string]CacheObject, len(c.store))
	for k, v := range c.store {
		ret[k] = v
	}
	return ret
}

type CacheObject struct {
	Subject  pkix.Name
	NotAfter time.Time
	Paths    []PathObject
}

type PathObject struct {
	Location string
	Source   string
}

func (lhs PathObject) LessThan(rhs PathObject) bool {
	if lhs.Source == rhs.Source {
		return lhs.Location < rhs.Location
	}

	return lhs.Source < rhs.Source
}

$$--GLUE--$$
.\server\config.go
$$--GLUE--$$
package server

import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"

	"github.com/doomsday-project/doomsday/server/auth"
	"github.com/doomsday-project/doomsday/server/notify"
	yaml "gopkg.in/yaml.v2"
)

type Config struct {
	Backends      []BackendConfig `yaml:"backends"`
	Server        APIConfig       `yaml:"server"`
	Notifications notify.Config   `yaml:"notifications"`
}

type APIConfig struct {
	Port    uint16 `yaml:"port"`
	LogFile string `yaml:"logfile"`
	TLS     struct {
		Cert string `yaml:"cert"`
		Key  string `yaml:"key"`
	} `yaml:"tls"`
	Auth auth.Config `yaml:"auth"`
	Dev  struct {
		Mappings map[string]string `yaml:"mappings"`
	} `yaml:"dev"`
}

type BackendConfig struct {
	Type string `yaml:"type"`
	Name string `yaml:"name"`
	//in minutes
	RefreshInterval int                    `yaml:"refresh_interval"`
	Properties      map[string]interface{} `yaml:"properties"`
}

func ParseConfig(path string) (*Config, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("Could not open config at `%s': %s", path, err)
	}

	fileContents, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("Could not read from config (%s): %s", path, err)
	}

	//Set defaults
	conf := Config{
		Server: APIConfig{
			Port: 8111,
		},
	}

	if os.Getenv("PORT") != "" {
		envPort, err := strconv.ParseUint(os.Getenv("PORT"), 10, 64)
		if err != nil {
			return nil, fmt.Errorf("Could not convert port to int")
		}

		conf.Server.Port = uint16(envPort)
	}

	//Read config
	err = yaml.Unmarshal(fileContents, &conf)
	if err != nil {
		return nil, fmt.Errorf("Could not parse config (%s) as YAML: %s", path, err)
	}

	//Post Defaults
	for i, b := range conf.Backends {
		if b.RefreshInterval == 0 {
			conf.Backends[i].RefreshInterval = 30
		}
	}

	//Validation
	if conf.Server.Port > 65535 {
		return nil, fmt.Errorf("Port number is invalid")
	}

	for _, b := range conf.Backends {
		if b.RefreshInterval <= 0 {
			return nil, fmt.Errorf("Refresh interval for backend must be greater than or equal to 0 - got %d", b.RefreshInterval)
		}
	}

	return &conf, nil
}

$$--GLUE--$$
.\server\core.go
$$--GLUE--$$
package server

import (
	"crypto/sha1"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"runtime"
	"strconv"
	"strings"
	"sync"

	"github.com/doomsday-project/doomsday/storage"
	yaml "gopkg.in/yaml.v2"
)

type Core struct {
	Backend   storage.Accessor
	Name      string
	cache     *Cache
	cacheLock sync.RWMutex
}

type PopulateStats struct {
	NumPaths   int
	NumSuccess int
	NumCerts   int
}

func (b *Core) SetCache(c *Cache) {
	b.cacheLock.Lock()
	defer b.cacheLock.Unlock()
	c.lock = &b.cacheLock
	b.cache = c
}

func (b *Core) Cache() *Cache {
	return b.cache
}

func (b *Core) Populate() (*PopulateStats, error) {
	newCache := NewCache()
	paths, err := b.Backend.List()
	if err != nil {
		return nil, err
	}

	results, err := b.populateUsing(newCache, paths)
	if err != nil {
		return nil, err
	}

	b.SetCache(newCache)
	return results, nil
}

type x509CertWrapper struct {
	path string
	cert *x509.Certificate
}

func (b *Core) populateUsing(cache *Cache, paths storage.PathList) (*PopulateStats, error) {
	if cache == nil {
		panic("Was given a nil cache")
	}

	var numWorkers = runtime.NumCPU() - 1
	if numWorkers < 1 {
		numWorkers = 1
	}
	if len(paths) < numWorkers {
		numWorkers = len(paths)
	}

	barrier := sync.WaitGroup{}
	barrier.Add(numWorkers)

	queue := make(chan string, len(paths))
	for _, path := range paths {
		queue <- path
	}
	close(queue)

	certCount := 0
	successCount := 0
	statLock := sync.Mutex{}

	var errLock sync.Mutex
	var errors []error

	fetch := func() {
		mySuccessCount, myCertCount := 0, 0
		for path := range queue {
			secret, err := b.Backend.Get(path)
			if err != nil {
				errLock.Lock()
				errors = append(errors, err)
				errLock.Unlock()
				continue
			}

			for k, v := range secret {
				certs := wrapCerts(parseCert(v), k)
				if len(certs) == 0 {
					keys, err := parseYAMLKeys(v)
					if err == nil {
						for _, str := range keys {
							certs = append(certs, wrapCerts(parseCert(str.Value), k+":"+str.Path)...)
						}
					}
				}
				for _, cert := range certs {
					myCertCount++
					cache.Merge(
						fmt.Sprintf("%s", sha1.Sum(cert.cert.Raw)),
						CacheObject{
							Subject:  cert.cert.Subject,
							NotAfter: cert.cert.NotAfter,
							Paths: []PathObject{
								{
									Location: path + ":" + cert.path,
									Source:   b.Name,
								},
							},
						},
					)
				}
			}
			mySuccessCount++
		}
		statLock.Lock()
		successCount += mySuccessCount
		certCount += myCertCount
		statLock.Unlock()
		barrier.Done()
	}

	for i := 0; i < numWorkers; i++ {
		go fetch()
	}

	barrier.Wait()

	if len(errors) == 0 {
		errors = append(errors, nil)
	}

	return &PopulateStats{
		NumPaths:   len(paths),
		NumSuccess: successCount,
		NumCerts:   certCount,
	}, errors[0]
}

func parseCert(c string) []*x509.Certificate {
	certs := []*x509.Certificate{}
	//Populate a potential chain of certs (or even just one) into this here slice
	var pemBlock *pem.Block
	var rest = []byte(c)
	for {
		pemBlock, rest = pem.Decode(rest)
		//Skip over potential private keys in a cert chain.
		if pemBlock == nil {
			break
		}

		if pemBlock.Type != "CERTIFICATE" {
			continue
		}

		cert, err := x509.ParseCertificate(pemBlock.Bytes)
		if err != nil {
			continue
		}

		certs = append(certs, cert)
		if len(rest) == 0 {
			break
		}
	}

	return certs
}

func wrapCerts(certs []*x509.Certificate, path string) (ret []x509CertWrapper) {
	for _, c := range certs {
		ret = append(ret, x509CertWrapper{
			path: path,
			cert: c,
		})
	}

	return ret
}

type YAMLKey struct {
	Path  string
	Value string
}

func parseYAMLKeys(y string) ([]YAMLKey, error) {
	var output interface{}
	err := yaml.Unmarshal([]byte(y), &output)
	if err != nil {
		return nil, err
	}

	ret := recurseTree(output, nil)

	return ret, nil
}

func recurseTree(obj interface{}, curPath []string) (ret []YAMLKey) {
	switch t := obj.(type) {
	case string:
		ret = append(ret, YAMLKey{
			Path:  treePath(curPath),
			Value: t,
		})
	case map[interface{}]interface{}:
		for k, v := range t {
			var kAsString string
			switch t2 := k.(type) {
			case string:
				kAsString = t2
			case int:
				kAsString = strconv.Itoa(t2)
			case bool:
				if t2 {
					kAsString = "true"
				} else {
					kAsString = "false"
				}
			}
			ret = append(ret, recurseTree(v, append(curPath, kAsString))...)
		}
	case []interface{}:
		for i, v := range t {
			ret = append(ret, recurseTree(v, append(curPath, strconv.Itoa(i)))...)
		}
	}

	return ret
}

func treePath(path []string) string {
	if len(path) == 0 {
		return "(root)"
	}

	return strings.Join(path, ".")
}

$$--GLUE--$$
.\server\logger\logger.go
$$--GLUE--$$
package logger

import (
	"fmt"
	"os"
	"time"
)

type Logger struct {
	f *os.File
}

func NewLogger(f *os.File) *Logger {
	return &Logger{f: f}
}

func (l *Logger) WriteF(s string, a ...interface{}) {
	timestamp := time.Now().Format(time.Stamp)
	l.Write([]byte(fmt.Sprintf(fmt.Sprintf("%s: %s\n", timestamp, s), a...)))
}

func (l *Logger) Write(b []byte) (int, error) {
	return fmt.Fprintf(l.f, "%s", b)
}

$$--GLUE--$$
.\server\notify\backend\backend.go
$$--GLUE--$$
package backend

import (
	"fmt"
	"strings"

	"github.com/doomsday-project/doomsday/server/logger"
	yaml "gopkg.in/yaml.v2"
)

type Backend interface {
	OK() error
	Soon() error
	Expired() error
}

type Config struct {
	Type       string                 `yaml:"type"`
	Properties map[string]interface{} `yaml:"properties"`
}

type BackendUniversalConfig struct {
	DoomsdayURL string
	Logger      *logger.Logger
}

const (
	typeUnknown int = iota
	typeSlack
	typeShout
)

func New(conf Config, uni BackendUniversalConfig) (Backend, error) {
	properties, err := yaml.Marshal(&conf.Properties)
	if err != nil {
		panic("Could not re-marshal into YAML")
	}

	t := resolveType(strings.ToLower(conf.Type))
	if t == typeUnknown {
		return nil, fmt.Errorf("Unrecognized backend type (%s)", conf.Type)
	}

	var c interface{}

	switch t {
	case typeSlack:
		c = &SlackConfig{}
		err = yaml.Unmarshal(properties, c.(*SlackConfig))
	case typeShout:
		c = &ShoutConfig{}
		err = yaml.Unmarshal(properties, c.(*ShoutConfig))
	}

	if err != nil {
		return nil, fmt.Errorf("Error when parsing backend config: %s", err)
	}

	var backend Backend
	switch t {
	case typeSlack:
		backend, err = newSlackBackend(*c.(*SlackConfig), uni)
	case typeShout:
		backend, err = newShoutBackend(*c.(*ShoutConfig), uni)
	}

	return backend, err
}

func resolveType(t string) int {
	switch t {
	case "slack":
		return typeSlack
	case "shout", "shout!":
		return typeShout
	default:
		return typeUnknown
	}
}

const (
	msgOK      = "No certs are expiring soon"
	msgSoon    = "Warning! There are certs expiring soon"
	msgExpired = "AHHH! There are expired certs!"
)

$$--GLUE--$$
.\server\notify\backend\shout.go
$$--GLUE--$$
package backend

import (
	"fmt"
	"net/url"
	"time"

	shout "github.com/thomasmitchell/go-shout"
)

type ShoutConfig struct {
	URL      string `yaml:"url"`
	Topic    string `yaml:"topic"`
	Username string `yaml:"username"`
	Password string `yaml:"password"`
}

type Shout struct {
	client         shout.Client
	topic          string
	doomsdayDomain string
}

func newShoutBackend(c ShoutConfig, uni BackendUniversalConfig) (*Shout, error) {
	if c.URL == "" {
		return nil, fmt.Errorf("No URL provided")
	}

	if c.Topic == "" {
		return nil, fmt.Errorf("No topic name provided")
	}

	if c.Username == "" {
		return nil, fmt.Errorf("No username provided")
	}

	if c.Password == "" {
		return nil, fmt.Errorf("No password provided")
	}

	if u, err := url.Parse(c.URL); err != nil || u.Host == "" {
		return nil, fmt.Errorf("URL not parsable")
	}
	return &Shout{
		client: shout.Client{
			Target:   c.URL,
			Username: c.Username,
			Password: c.Password,
			Trace:    uni.Logger,
		},
		topic:          c.Topic,
		doomsdayDomain: uni.DoomsdayURL,
	}, nil
}

func (s Shout) OK() error {
	return s.client.PostEvent(shout.EventIn{
		Topic:      s.topic,
		Message:    msgOK,
		Link:       s.doomsdayDomain,
		OccurredAt: time.Now(),
		OK:         true,
	})
}

func (s Shout) Soon() error {
	return s.client.PostEvent(shout.EventIn{
		Topic:      s.topic,
		Message:    msgSoon,
		Link:       s.doomsdayDomain,
		OccurredAt: time.Now(),
		OK:         false,
	})
}

func (s Shout) Expired() error {
	return s.client.PostEvent(shout.EventIn{
		Topic:      s.topic,
		Message:    msgExpired,
		Link:       s.doomsdayDomain,
		OccurredAt: time.Now(),
		OK:         false,
	})
}

$$--GLUE--$$
.\server\notify\backend\slack.go
$$--GLUE--$$
package backend

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
)

type SlackConfig struct {
	Webhook  string `yaml:"webhook"`
	NotifyOK bool   `yaml:"notify_ok"`
}

type Slack struct {
	webhook  string
	topic    string
	notifyOK bool
}

func newSlackBackend(c SlackConfig, uni BackendUniversalConfig) (*Slack, error) {
	if c.Webhook == "" {
		return nil, fmt.Errorf("No webhook provided")
	}

	if _, err := url.Parse(c.Webhook); err != nil {
		return nil, fmt.Errorf("Webhook not parsable as URL")
	}
	return &Slack{
		webhook: c.Webhook,
		topic:   fmt.Sprintf("%s<%s>%s", slackQuoteMeta("doomsday: ("), uni.DoomsdayURL, "): "),
	}, nil
}

func (s Slack) OK() error {
	var err error
	if s.notifyOK {
		err = s.send(msgOK)
	}
	return err
}

func (s Slack) Soon() error {
	return s.send(msgSoon)
}

func (s Slack) Expired() error {
	return s.send(msgExpired)
}

func (s Slack) send(msg string) error {
	body, err := json.Marshal(&map[string]string{
		"text": s.topic + slackQuoteMeta(msg),
	})
	if err != nil {
		panic("We tried to send a nil message")
	}
	r, err := http.NewRequest("POST", s.webhook, bytes.NewReader(body))
	if err != nil {
		return fmt.Errorf("Error when making request: %s", err)
	}

	r.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(r)
	if err != nil {
		return fmt.Errorf("Error sending request: %s", err)
	}

	if resp.StatusCode >= 300 {
		return fmt.Errorf("Status non-2xx: %d", resp.StatusCode)
	}

	return nil
}

func slackQuoteMeta(s string) string {
	s = strings.Replace(s, "&", "&amp;", -1)
	s = strings.Replace(s, "<", "&lt;", -1)
	s = strings.Replace(s, ">", "&gt;", -1)
	s = strings.Replace(s, "\r\n", "\\n", -1)
	s = strings.Replace(s, "\n", "\\n", -1)
	return s
}

$$--GLUE--$$
.\server\notify\config.go
$$--GLUE--$$
package notify

import (
	"github.com/doomsday-project/doomsday/server/notify/backend"
	"github.com/doomsday-project/doomsday/server/notify/schedule"
)

type Config struct {
	Backend     backend.Config  `yaml:"backend"`
	Schedule    schedule.Config `yaml:"schedule"`
	DoomsdayURL string          `yaml:"doomsday_url"`
}

$$--GLUE--$$
.\server\notify\schedule\constant.go
$$--GLUE--$$
package schedule

import (
	"fmt"
	"time"
)

type Constant struct {
	interval time.Duration
	c        chan bool
}

type ConstantConfig struct {
	Interval int `yaml:"interval"`
}

func newConstantSchedule(conf ConstantConfig) (*Constant, error) {
	if conf.Interval <= 0 {
		return nil, fmt.Errorf("Interval must be greater than 0")
	}

	return &Constant{
		interval: time.Duration(conf.Interval) * time.Minute,
		c:        make(chan bool),
	}, nil
}

func (c *Constant) Start() {
	go func() {
		for range time.Tick(c.interval) {
			c.c <- true
		}
	}()
}

func (c *Constant) Channel() chan bool {
	return c.c
}

$$--GLUE--$$
.\server\notify\schedule\cron.go
$$--GLUE--$$
package schedule

import (
	"fmt"
	"time"

	"github.com/robfig/cron"
)

type Cron struct {
	sched cron.Schedule
	c     chan bool
}

type CronConfig struct {
	Spec string `yaml:"spec"`
}

func newCronSchedule(conf CronConfig) (*Cron, error) {
	if conf.Spec == "" {
		return nil, fmt.Errorf("Cron spec must be given")
	}

	ret := &Cron{c: make(chan bool)}
	var err error

	ret.sched, err = cron.ParseStandard(conf.Spec)
	if err != nil {
		return nil, fmt.Errorf("Could not parse cron spec: %s", err)
	}

	return ret, nil
}

func (c *Cron) Start() {
	go func() {
		t := time.Now()
		for {
			t = c.sched.Next(t)
			time.Sleep(time.Until(t))
			c.c <- true
		}
	}()
}

func (c *Cron) Channel() chan bool {
	return c.c
}

$$--GLUE--$$
.\server\notify\schedule\schedule.go
$$--GLUE--$$
package schedule

import (
	"fmt"
	"strings"

	yaml "gopkg.in/yaml.v2"
)

type Schedule interface {
	Start()
	Channel() chan bool
}

type Config struct {
	Type       string                 `yaml:"type"`
	Properties map[string]interface{} `yaml:"properties"`
}

const (
	typeUnknown int = iota
	typeConstant
	typeCron
)

func New(scheduleType string, conf map[string]interface{}) (Schedule, error) {
	properties, err := yaml.Marshal(&conf)
	if err != nil {
		panic("Could not re-marshal into YAML")
	}

	t := resolveType(strings.ToLower(scheduleType))
	if t == typeUnknown {
		return nil, fmt.Errorf("Unrecognized schedule type (%s)", scheduleType)
	}

	var c interface{}

	switch t {
	case typeConstant:
		c = &ConstantConfig{}
		err = yaml.Unmarshal(properties, c.(*ConstantConfig))
	case typeCron:
		c = &CronConfig{}
		err = yaml.Unmarshal(properties, c.(*CronConfig))
	}

	if err != nil {
		return nil, fmt.Errorf("Error when parsing backend config: %s", err)
	}

	var schedule Schedule
	switch t {
	case typeConstant:
		schedule, err = newConstantSchedule(*c.(*ConstantConfig))
	case typeCron:
		schedule, err = newCronSchedule(*c.(*CronConfig))
	}

	return schedule, err
}

func resolveType(t string) int {
	switch t {
	case "constant", "interval":
		return typeConstant
	case "cron", "cronspec":
		return typeCron
	default:
		return typeUnknown
	}
}

$$--GLUE--$$
.\server\notify.go
$$--GLUE--$$
package server

import (
	"fmt"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/doomsday-project/doomsday/server/logger"
	"github.com/doomsday-project/doomsday/server/notify"
	"github.com/doomsday-project/doomsday/server/notify/backend"
	"github.com/doomsday-project/doomsday/server/notify/schedule"
)

type notifier struct {
	s schedule.Schedule
	b backend.Backend
}

func NotifyFrom(conf notify.Config, m *SourceManager, l *logger.Logger) error {
	var n notifier
	var err error

	if conf.DoomsdayURL == "" {
		return fmt.Errorf("Please provide doomsday_url")
	}
	n.s, err = schedule.New(conf.Schedule.Type, conf.Schedule.Properties)
	if err != nil {
		return fmt.Errorf("Error creating schedule: %s", err)
	}

	uni := backend.BackendUniversalConfig{
		DoomsdayURL: conf.DoomsdayURL,
		Logger:      l,
	}
	n.b, err = backend.New(conf.Backend, uni)
	if err != nil {
		return fmt.Errorf("Error creating backend: %s", err)
	}

	n.s.Start()
	go func() {
		for range n.s.Channel() {
			l.WriteF("Triggering notification check")
			const (
				StateOK = iota
				StateExpired
				StateSoon
			)

			d := m.Data()
			state := StateOK
			expiredThreshold := time.Duration(0)
			expiringSoonThreshold := time.Hour * 24 * 7 * 4
			if len(d.Filter(doomsday.CacheItemFilter{Within: &expiredThreshold})) > 0 {
				state = StateExpired
			} else if len(d.Filter(doomsday.CacheItemFilter{Within: &expiringSoonThreshold})) > 0 {
				state = StateSoon
			}

			var sendErr error
			switch state {
			case StateOK:
				l.WriteF("No expiring certs")
				sendErr = n.b.OK()
			case StateSoon:
				l.WriteF("Certs expiring soon")
				sendErr = n.b.Soon()
			case StateExpired:
				l.WriteF("Certs expired")
				sendErr = n.b.Expired()
			}
			if sendErr != nil {
				l.WriteF("Could not send notification: %s", sendErr)
			}
		}
	}()

	return nil
}

$$--GLUE--$$
.\server\scheduler.go
$$--GLUE--$$
package server

import (
	"bytes"
	"encoding/json"
	"sort"
	"sync"
	"time"

	"github.com/doomsday-project/doomsday/server/logger"
)

type taskKind uint

const (
	//the order of these actually matters, because it is used for
	// prioritization when sorting the queue
	queueTaskKindAuth taskKind = iota
	queueTaskKindRefresh
)

func (t taskKind) String() string {
	switch t {
	case queueTaskKindAuth:
		return "auth"
	case queueTaskKindRefresh:
		return "refresh"
	default:
		return "unknown"
	}
}

type runReason uint

const (
	runReasonSchedule runReason = iota
	runReasonAdhoc
)

func (r runReason) String() string {
	switch r {
	case runReasonSchedule:
		return "scheduled"
	case runReasonAdhoc:
		return "adhoc"
	default:
		return "unknown"
	}
}

type taskState uint

const (
	//the order of these actually matters, because it is used for
	// prioritization when sorting the queue
	queueTaskStatePending = iota
	queueTaskStateReady
	queueTaskStateSkip
)

func (s taskState) String() string {
	switch s {
	case queueTaskStatePending:
		return "pending"
	case queueTaskStateReady:
		return "ready"
	case queueTaskStateSkip:
		return "skipping"
	default:
		return "unknown"
	}
}

type managerTask struct {
	id             uint
	kind           taskKind
	source         *Source
	runTime        time.Time
	reason         runReason
	state          taskState
	assignedWorker *taskWorker
}

func (m *managerTask) durationUntil() time.Duration {
	return m.runTime.Sub(time.Now())
}

func (m *managerTask) run(cache *Cache, log *logger.Logger) {
	switch m.kind {
	case queueTaskKindAuth:
		m.source.Auth(log)

	case queueTaskKindRefresh:
		m.source.Refresh(cache, log)
	}
}

type managerTasks []managerTask

type taskQueue struct {
	data        managerTasks
	running     managerTasks
	lock        *sync.Mutex
	cond        *sync.Cond
	log         *logger.Logger
	globalCache *Cache
	numWorkers  uint
	workers     []*taskWorker
	nextTaskID  uint
}

func newTaskQueue(cache *Cache, numWorkers uint, log *logger.Logger) *taskQueue {
	lock := &sync.Mutex{}
	return &taskQueue{
		lock:        lock,
		log:         log,
		cond:        sync.NewCond(lock),
		globalCache: cache,
		numWorkers:  numWorkers,
	}
}

//enqueue puts a task into the queue, unique by the tuple source, taskType. If
//there already exists a task for this source/taskType, it will be removed and
//replaced with this new one atomically.
func (t *taskQueue) enqueue(task managerTask) {
	t.lock.Lock()
	task.id = t.nextTaskID
	t.nextTaskID++
	t.log.WriteF("Enqueuing new %s %s task for backend `%s' with id %d", task.reason, task.kind, task.source.Core.Name, task.id)
	t.data = append(t.data, task)
	t.data.sort()
	t.lock.Unlock()

	time.AfterFunc(time.Until(task.runTime), func() {
		t.lock.Lock()
		defer t.lock.Unlock()

		foundTask := t.data.findTaskWithID(task.id)
		if foundTask == nil {
			t.log.WriteF("Skipping marking task as ready because it has been removed pre-emptively (id %d)",
				task.id)
			return
		}

		if t.data.sameTaskExistsAndReady(foundTask) || t.running.sameTaskExistsAndReady(foundTask) {
			t.log.WriteF("Marking %s %s task for backend `%s' as to skip (id %d)",
				foundTask.reason, foundTask.kind, foundTask.source.Core.Name, task.id)
			foundTask.state = queueTaskStateSkip
		} else {
			t.log.WriteF("Marking %s %s task for backend `%s' as ready (id %d)",
				foundTask.reason, foundTask.kind, foundTask.source.Core.Name, task.id)
			foundTask.state = queueTaskStateReady
		}

		t.data.sort()
		t.cond.Signal()
	})
}

func (t managerTasks) idxWithID(id uint) int {
	var ret int = -1
	for i := range t {
		if t[i].id == id {
			ret = i
			break
		}
	}

	return ret
}

//sort priority:
// 1. skip<ready<pending
// 2. auth before refresh if both are ready
// 3. scheduled time
// 4. id
func (t managerTasks) sort() {
	sort.Slice(t, func(i, j int) bool {
		if t[i].state != t[j].state {
			return t[i].state > t[j].state
		}

		if t[i].kind != t[j].kind {
			return t[i].kind < t[j].kind
		}

		if !t[i].runTime.Equal(t[j].runTime) {
			return t[i].runTime.Before(t[j].runTime)
		}

		return t[i].id < t[j].id
	})
}

//If the queue order is shuffled in any way after a call to this function, the
// returned pointer is invalidated. Therefore, you should only call this and
// manipulate the returned object while you are holding the lock
func (t managerTasks) findTaskWithID(id uint) *managerTask {
	var ret *managerTask
	if idx := t.idxWithID(id); idx >= 0 {
		ret = &t[idx]
	}

	return ret
}

//no lock
//considered the same task if the associated source core has the same name, and
// the kind of task is the same. Considered ready if the ready member of the task
// is true.
func (t managerTasks) sameTaskExistsAndReady(task *managerTask) bool {
	for i := range t {
		if t[i].source.Core.Name == task.source.Core.Name &&
			t[i].kind == task.kind &&
			t[i].state == queueTaskStateReady {
			return true
		}
	}

	return false
}

func (t *managerTasks) deleteTaskWithID(id uint) {
	if idx := t.idxWithID(id); idx >= 0 {
		(*t)[idx] = (*t)[len(*t)-1]
		*t = (*t)[:len(*t)-1]
		(*t).sort()
	}
}

func (t *taskQueue) dequeueNoLock() managerTask {
	ret := t.data[0]
	t.data[0] = t.data[len(t.data)-1]
	t.data = t.data[:len(t.data)-1]
	t.data.sort()

	return ret
}

func (t *taskQueue) empty() bool {
	return len(t.data) == 0
}

func (t *taskQueue) start() {
	workerFactory := newTaskWorkerFactory(t, t.globalCache, t.log)
	for i := uint(0); i < t.numWorkers; i++ {
		t.workers = append(t.workers, workerFactory.newWorker())
		t.workers[i].consumeScheduler()
	}
}

type SchedulerState struct {
	Running []SchedulerTask `json:"running"`
	Pending []SchedulerTask `json:"pending"`
	Workers []WorkerDump    `json:"workers"`
}

func (s SchedulerState) String() string {
	b, _ := json.Marshal(s)
	bOut := bytes.Buffer{}
	json.Indent(&bOut, b, "", "  ")
	return bOut.String()
}

type SchedulerTask struct {
	ID       uint      `json:"id"`
	At       time.Time `json:"at"`
	Backend  string    `json:"backend"`
	Reason   string    `json:"reason"`
	Kind     string    `json:"kind"`
	State    string    `json:"state"`
	WorkerID int       `json:"worker"`
}

type WorkerDump struct {
	ID      uint      `json:"id"`
	State   string    `json:"state"`
	StateAt time.Time `json:"state_at"`
}

func (t *taskQueue) dumpState() SchedulerState {
	t.lock.Lock()
	defer t.lock.Unlock()
	return t.dumpStateNoLock()
}

func (t *taskQueue) dumpStateNoLock() SchedulerState {
	ret := SchedulerState{
		Running: []SchedulerTask{},
		Pending: []SchedulerTask{},
	}

	for _, task := range t.running {
		ret.Running = append(ret.Running, SchedulerTask{
			ID:       task.id,
			At:       task.runTime,
			Backend:  task.source.Core.Name,
			Reason:   task.reason.String(),
			Kind:     task.kind.String(),
			State:    task.state.String(),
			WorkerID: int(task.assignedWorker.id),
		})
	}

	for _, task := range t.data {
		ret.Pending = append(ret.Pending, SchedulerTask{
			ID:       task.id,
			At:       task.runTime,
			Backend:  task.source.Core.Name,
			Reason:   task.reason.String(),
			Kind:     task.kind.String(),
			State:    task.state.String(),
			WorkerID: -1,
		})
	}

	for _, worker := range t.workers {
		state, stateAt := worker.State()
		ret.Workers = append(ret.Workers, WorkerDump{
			ID:      worker.id,
			State:   state.String(),
			StateAt: stateAt,
		})
	}

	return ret
}

$$--GLUE--$$
.\server\server.go
$$--GLUE--$$
package server

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/doomsday-project/doomsday/server/auth"
	"github.com/doomsday-project/doomsday/server/logger"
	"github.com/doomsday-project/doomsday/storage"
	"github.com/doomsday-project/doomsday/version"
	"github.com/gorilla/mux"
)

var log *logger.Logger

func Start(conf Config) error {
	var err error

	log = logger.NewLogger(os.Stderr)
	if conf.Server.LogFile != "" {
		var logTarget *os.File
		logTarget, err = os.OpenFile(conf.Server.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("Could not open log file for writing: %s", err)
		}

		log = logger.NewLogger(logTarget)
	}

	log.WriteF("Initializing server")
	log.WriteF("Configuring targeted storage backends")

	sources := make([]Source, 0, len(conf.Backends))
	for _, b := range conf.Backends {
		backendName := b.Name
		if backendName == "" {
			backendName = b.Type
		}

		log.WriteF("Configuring backend `%s' of type `%s'", b.Name, b.Type)
		thisBackend, authState, err := storage.NewAccessor(b.Type, b.Properties)
		if err != nil {
			return fmt.Errorf("Error configuring backend `%s': %s", b.Name, err)
		}

		thisCore := Core{Backend: thisBackend, Name: backendName}
		thisCore.SetCache(NewCache())

		sources = append(sources,
			Source{
				Core:         &thisCore,
				Interval:     time.Duration(b.RefreshInterval) * time.Minute,
				authMetadata: authState,
			},
		)
	}

	manager := NewSourceManager(sources, log)

	log.WriteF("Starting background scheduler")

	err = manager.BackgroundScheduler()
	if err != nil {
		return fmt.Errorf("Error starting scheduler: %s", err)
	}

	log.WriteF("Began asynchronous cache population")
	log.WriteF("Configuring frontend authentication")

	authorizer, err := auth.NewAuth(conf.Server.Auth)
	if err != nil {
		return err
	}

	if conf.Notifications.Schedule.Type != "" {
		err = NotifyFrom(conf.Notifications, manager, log)
		if err != nil {
			return fmt.Errorf("Error setting up notifications: %s", err)
		}

		log.WriteF("Notifications configured")
	}

	auth := authorizer.TokenHandler()
	router := mux.NewRouter()
	router.HandleFunc("/v1/info", getInfo(authorizer.Identifier())).Methods("GET")
	router.HandleFunc("/v1/auth", authorizer.LoginHandler()).Methods("POST")
	router.HandleFunc("/v1/cache", auth(getCache(manager))).Methods("GET")
	router.HandleFunc("/v1/cache/refresh", auth(refreshCache(manager))).Methods("POST")
	router.HandleFunc("/v1/scheduler", auth(getScheduler(manager))).Methods("GET")

	if len(conf.Server.Dev.Mappings) > 0 {
		for file, servePath := range conf.Server.Dev.Mappings {
			servePath = "/" + strings.TrimPrefix(servePath, "/")
			log.WriteF("Serving %s at %s", file, servePath)
			router.HandleFunc(servePath, serveDevFile(file)).Methods("GET")
		}
	} else {
		for path, value := range webStatics {
			router.HandleFunc(path, serveFile(value.Content, value.MIMEType)).Methods("GET")
		}
	}

	log.WriteF("Beginning listening on port %d", conf.Server.Port)

	if conf.Server.TLS.Cert != "" || conf.Server.TLS.Key != "" {
		err = listenAndServeTLS(&conf, router)
	} else {
		err = http.ListenAndServe(fmt.Sprintf(":%d", conf.Server.Port), router)
	}

	return err
}

func listenAndServeTLS(conf *Config, handler http.Handler) error {
	ln, err := net.Listen("tcp", fmt.Sprintf(":%d", conf.Server.Port))
	if err != nil {
		return err
	}

	defer ln.Close()

	cert, err := tls.X509KeyPair([]byte(conf.Server.TLS.Cert), []byte(conf.Server.TLS.Key))
	if err != nil {
		return err
	}

	tlsListener := tls.NewListener(ln, &tls.Config{
		NextProtos:   []string{"http/1.1"},
		Certificates: []tls.Certificate{cert},
	})

	return http.Serve(tlsListener, handler)
}

func getInfo(authType auth.AuthType) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		b, err := json.Marshal(struct {
			Version  string `json:"version"`
			AuthType string `json:"auth_type"`
		}{
			Version:  version.Version,
			AuthType: string(authType),
		})
		if err != nil {
			panic("Could not marshal info into json")
		}

		w.Header().Set("Content-Type", "application/json")
		writeBody(w, b)
	}
}

func getCache(manager *SourceManager) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		items := manager.Data()
		sort.Slice(items, func(i, j int) bool { return items[i].NotAfter < items[j].NotAfter })

		resp, err := json.Marshal(&doomsday.GetCacheResponse{Content: items})
		if err != nil {
			w.WriteHeader(500)
		} else {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(200)
			writeBody(w, resp)
		}
	}
}

func refreshCache(manager *SourceManager) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		go manager.RefreshAll()
		w.WriteHeader(204)
	}
}

func getScheduler(manager *SourceManager) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		schedData := manager.SchedulerState()
		respRaw := doomsday.GetSchedulerResponse{
			Running: []doomsday.GetSchedulerTask{},
			Pending: []doomsday.GetSchedulerTask{},
		}

		for i := range schedData.Workers {
			respRaw.Workers = append(respRaw.Workers, doomsday.GetSchedulerWorker{
				ID:      schedData.Workers[i].ID,
				State:   schedData.Workers[i].State,
				StateAt: schedData.Workers[i].StateAt.Unix(),
			})
		}

		for i := range schedData.Running {
			respRaw.Running = append(respRaw.Running, doomsday.GetSchedulerTask{
				At:       schedData.Running[i].At.Unix(),
				Backend:  schedData.Running[i].Backend,
				Reason:   schedData.Running[i].Reason,
				Kind:     schedData.Running[i].Kind,
				ID:       schedData.Running[i].ID,
				State:    schedData.Running[i].State,
				WorkerID: schedData.Running[i].WorkerID,
			})
		}

		for i := range schedData.Pending {
			respRaw.Pending = append(respRaw.Pending, doomsday.GetSchedulerTask{
				At:       schedData.Pending[i].At.Unix(),
				Backend:  schedData.Pending[i].Backend,
				Reason:   schedData.Pending[i].Reason,
				Kind:     schedData.Pending[i].Kind,
				ID:       schedData.Pending[i].ID,
				State:    schedData.Pending[i].State,
				WorkerID: -1,
			})
		}

		resp, err := json.Marshal(&respRaw)
		if err != nil {
			w.WriteHeader(500)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(200)
		writeBody(w, resp)
	}
}

func serveFile(content []byte, mimeType string) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", mimeType)
		w.WriteHeader(200)
		writeBody(w, content)
	}
}

func serveDevFile(filepath string) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		f, err := os.Open(filepath)
		if err != nil {
			w.WriteHeader(500)
			writeBody(w, []byte(fmt.Sprintf("Could not serve file: %s", filepath)))
			return
		}

		contents, err := ioutil.ReadAll(f)
		if err != nil {
			w.WriteHeader(500)
			writeBody(w, []byte("Could not read contents of file"))
			return
		}

		contentType := "text/plain"
		if strings.HasSuffix(filepath, ".html") {
			contentType = "text/html"
		} else if strings.HasSuffix(filepath, ".css") {
			contentType = "text/css"
		} else if strings.HasSuffix(filepath, ".js") {
			contentType = "application/javascript"
		} else if strings.HasSuffix(filepath, ".svg") {
			contentType = "image/svg+xml"
		} else if strings.HasSuffix(filepath, ".woff2") {
			contentType = "font/opentype"
		}

		w.Header().Set("Content-Type", contentType)

		w.WriteHeader(200)
		writeBody(w, contents)
		f.Close()
	}
}

func writeBody(w http.ResponseWriter, contents []byte) {
	_, err := w.Write(contents)
	if err != nil {
		log.WriteF("%s", err.Error())
	}
}

$$--GLUE--$$
.\server\source.go
$$--GLUE--$$
package server

import (
	"sync"
	"time"

	"github.com/doomsday-project/doomsday/server/logger"
	"github.com/doomsday-project/doomsday/storage"
)

type Source struct {
	Core     *Core
	Interval time.Duration
	lock     sync.RWMutex
	authTTL  time.Duration

	refreshStatus RunInfo
	authStatus    RunInfo
	authMetadata  interface{}
}

type RunInfo struct {
	LastRun     RunTiming
	LastSuccess RunTiming
	LastErr     error
}

type RunTiming struct {
	StartedAt  time.Time
	FinishedAt time.Time
}

func (s *Source) Refresh(global *Cache, log *logger.Logger) {
	log.WriteF("Running populate of `%s'", s.Core.Name)

	old := s.Core.Cache()
	if old == nil {
		old = NewCache()
	}

	s.lock.Lock()
	s.refreshStatus.LastRun = RunTiming{StartedAt: time.Now()}
	s.lock.Unlock()

	results, err := s.Core.Populate()

	s.lock.Lock()
	defer s.lock.Unlock()

	s.refreshStatus.LastRun.FinishedAt = time.Now()

	if err != nil {
		log.WriteF("Error populating info from backend `%s': %s", s.Core.Name, err)
		s.refreshStatus.LastErr = err
		return
	}

	s.refreshStatus.LastErr = nil
	s.refreshStatus.LastSuccess = s.refreshStatus.LastRun

	global.ApplyDiff(old, s.Core.Cache())

	log.WriteF("Finished populate of `%s' after %s. %d/%d paths searched. %d certs found", s.Core.Name, time.Since(s.refreshStatus.LastRun.StartedAt), results.NumSuccess, results.NumPaths, results.NumCerts)
}

func (s *Source) Auth(log *logger.Logger) {
	log.WriteF("Starting authentication for `%s'", s.Core.Name)

	s.lock.Lock()
	s.authStatus.LastRun = RunTiming{StartedAt: time.Now()}
	s.lock.Unlock()

	ttl, metadata, err := s.Core.Backend.Authenticate(s.authMetadata)

	s.lock.Lock()
	defer s.lock.Unlock()

	s.authStatus.LastRun.FinishedAt = time.Now()

	if err != nil {
		log.WriteF("Failed auth for `%s' after %s: %s", s.Core.Name, time.Since(s.authStatus.LastRun.StartedAt), err)
		s.authStatus.LastErr = err
		return
	}

	s.authStatus.LastErr = nil
	s.authStatus.LastSuccess = s.authStatus.LastRun

	s.authTTL = ttl
	s.authMetadata = metadata

	log.WriteF("Finished auth for `%s' after %s", s.Core.Name, time.Since(s.authStatus.LastRun.StartedAt))
}

//CalcNextAuth returns the time of the next authentication to attempt.
// The second return value is true if this should never be scheduled again
func (s *Source) CalcNextAuth() (time.Time, bool) {
	s.lock.RLock()
	defer s.lock.RUnlock()
	if s.authTTL == storage.TTLInfinite {
		return time.Time{}, true
	}

	expiryTime := s.authStatus.LastSuccess.StartedAt.Add(s.authTTL)
	authInterval := expiryTime.Sub(s.authStatus.LastRun.FinishedAt) / 2
	if authInterval < MinAuthInterval {
		authInterval = MinAuthInterval
	}

	nextAuth := s.authStatus.LastRun.FinishedAt.Add(authInterval)
	if nextAuth.After(expiryTime) {
		nextAuth = s.authStatus.LastRun.FinishedAt.Add(ExpiredRetryInterval)
	}

	return nextAuth, false
}

func (s *Source) CalcNextRefresh() time.Time {
	s.lock.RLock()
	ret := s.refreshStatus.LastRun.FinishedAt.Add(s.Interval)
	s.lock.RUnlock()
	return ret
}

$$--GLUE--$$
.\server\source_manager.go
$$--GLUE--$$
package server

import (
	"fmt"
	"sort"
	"time"

	"github.com/doomsday-project/doomsday/client/doomsday"
	"github.com/doomsday-project/doomsday/server/logger"
)

const (
	MinAuthInterval      = 5 * time.Second
	ExpiredRetryInterval = 5 * time.Minute
)

type SourceManager struct {
	sources []Source
	queue   *taskQueue
	log     *logger.Logger
	global  *Cache
}

func NewSourceManager(sources []Source, log *logger.Logger) *SourceManager {
	if log == nil {
		panic("No logger was given")
	}

	globalCache := NewCache()
	//TODO: Make the number of workers configurable
	queue := newTaskQueue(globalCache, 4, log)

	return &SourceManager{
		sources: sources,
		queue:   queue,
		log:     log,
		global:  globalCache,
	}
}

func (s *SourceManager) BackgroundScheduler() error {
	for i := range s.sources {
		s.sources[i].Auth(s.log)
		if s.sources[i].authStatus.LastErr != nil {
			return fmt.Errorf("Error performing initial auth for backend `%s': %s",
				s.sources[i].Core.Name,
				s.sources[i].authStatus.LastErr)
		}
	}

	now := time.Now()

	for i := range s.sources {
		s.queue.enqueue(managerTask{
			kind:    queueTaskKindRefresh,
			source:  &s.sources[i],
			runTime: now,
			reason:  runReasonSchedule,
		})

		nextAuthTime, skipAuth := s.sources[i].CalcNextAuth()
		if !skipAuth {
			s.queue.enqueue(managerTask{
				kind:    queueTaskKindAuth,
				source:  &s.sources[i],
				runTime: nextAuthTime,
				reason:  runReasonSchedule,
			})
		}
	}

	s.queue.start()
	return nil
}

func (s *SourceManager) Data() doomsday.CacheItems {
	items := []doomsday.CacheItem{}
	for _, v := range s.global.Map() {
		paths := []doomsday.CacheItemPath{}
		for _, path := range v.Paths {
			paths = append(paths, doomsday.CacheItemPath{
				Backend:  path.Source,
				Location: path.Location,
			})
		}
		items = append(items, doomsday.CacheItem{
			Paths:      paths,
			CommonName: v.Subject.CommonName,
			NotAfter:   v.NotAfter.Unix(),
		})
	}

	sort.Slice(items, func(i, j int) bool { return items[i].NotAfter < items[j].NotAfter })
	return items
}

func (s *SourceManager) RefreshAll() {
	now := time.Now()
	for i := range s.sources {
		s.queue.enqueue(managerTask{
			source:  &s.sources[i],
			kind:    queueTaskKindRefresh,
			runTime: now,
			reason:  runReasonAdhoc,
		})
	}
}

func (s *SourceManager) SchedulerState() SchedulerState {
	return s.queue.dumpState()
}

$$--GLUE--$$
.\server\task_worker.go
$$--GLUE--$$
package server

import (
	"sync"
	"time"

	"github.com/doomsday-project/doomsday/server/logger"
)

type taskWorkerFactory struct {
	sched *taskQueue
	cache *Cache
	log   *logger.Logger
	curID uint
}

func newTaskWorkerFactory(sched *taskQueue, cache *Cache, log *logger.Logger) *taskWorkerFactory {
	return &taskWorkerFactory{
		sched: sched,
		cache: cache,
		log:   log,
	}
}

func (f *taskWorkerFactory) newWorker() *taskWorker {
	ret := &taskWorker{
		sched:   f.sched,
		cache:   f.cache,
		log:     f.log,
		id:      f.curID,
		state:   WorkerStateIdle,
		stateAt: time.Now(),
	}

	f.curID++
	return ret
}

type taskWorker struct {
	sched *taskQueue
	cache *Cache
	log   *logger.Logger
	id    uint
	//Never try to grab the scheduler lock while holding this lock.
	// You can try to grab this lock while holding the scheduler lock, but
	// not in the reverse order.
	stateLock sync.RWMutex
	state     WorkerState
	stateAt   time.Time
}

//WorkerState is the current thing the worker is doing. i.e. idle vs running
type WorkerState uint

const (
	//WorkerStateIdle means the worker is currently waiting for a task
	WorkerStateIdle = iota
	//WorkerStateRunning means the worker is currently running a task
	WorkerStateRunning
	//WorkerStateScheduling means the worker is currently scheduling a future task
	WorkerStateScheduling
)

func (w WorkerState) String() string {
	ret := "unknown"
	switch w {
	case WorkerStateIdle:
		ret = "idle"
	case WorkerStateRunning:
		ret = "running"
	case WorkerStateScheduling:
		ret = "scheduling"
	}

	return ret
}

type taskWorkerState struct {
	state *WorkerState
}

func (w *taskWorker) consumeScheduler() {
	go func() {
		for {
			next := w.runNext()
			w.scheduleNextRunOf(next)
		}
	}()
}

//runNext blocks until there is a task for this worker to handle. it then
//dequeues and runs that task if it is not marked to skip.
func (w *taskWorker) runNext() managerTask {
	w.sched.lock.Lock()

	for w.sched.empty() || w.sched.data[0].state == queueTaskStatePending {
		w.sched.cond.Wait()
	}

	ret := w.sched.dequeueNoLock()

	if ret.state == queueTaskStateSkip {
		w.sched.lock.Unlock()
		w.log.WriteF("Worker %d skipping %s %s of `%s'", w.id, ret.reason, ret.kind, ret.source.Core.Name)
		return ret
	}

	ret.assignedWorker = w
	w.sched.running = append(w.sched.running, ret)
	w.SetState(WorkerStateRunning)
	w.sched.lock.Unlock()

	w.log.WriteF("Worker %d running %s %s of `%s'", w.id, ret.reason, ret.kind, ret.source.Core.Name)

	ret.run(w.cache, w.log)

	w.SetState(WorkerStateScheduling)
	w.sched.lock.Lock()
	w.sched.running.deleteTaskWithID(ret.id)
	w.sched.lock.Unlock()
	w.SetState(WorkerStateIdle)

	return ret
}

func (w *taskWorker) scheduleNextRunOf(task managerTask) {
	if task.reason == runReasonAdhoc {
		return
	}

	var nextTime time.Time
	var skipSched bool

	switch task.kind {
	case queueTaskKindAuth:
		nextTime, skipSched = task.source.CalcNextAuth()

	case queueTaskKindRefresh:
		nextTime = task.source.CalcNextRefresh()
	}

	if skipSched {
		w.log.WriteF("Skipping further scheduling of `%s' for `%s'", task.kind.String(), task.source.Core.Name)
		return
	}

	w.sched.enqueue(managerTask{
		source:  task.source,
		runTime: nextTime,
		reason:  runReasonSchedule,
		kind:    task.kind,
	})
}

//State returns the current state this worker is in, and the time that it
// entered that state at
func (w *taskWorker) State() (WorkerState, time.Time) {
	w.stateLock.RLock()
	defer w.stateLock.RUnlock()
	return w.state, w.stateAt
}

func (w *taskWorker) SetState(state WorkerState) {
	w.stateLock.Lock()
	defer w.stateLock.Unlock()
	w.state = state
	w.stateAt = time.Now()
}

$$--GLUE--$$
.\storage\accessor.go
$$--GLUE--$$
package storage

import (
	"fmt"
	"strings"
	"time"

	yaml "gopkg.in/yaml.v2"
)

type Accessor interface {
	List() (PathList, error)
	Get(path string) (map[string]string, error)
	//Authenticate receives metadata returned from the last run of a call to
	//authenticate. It is guaranteed to receive the value that was returned by
	//its constructor on the first run. It should return the new TTL, any
	//metadata to send to the next run, and an error if one occurred.
	//Authenticate must be called at some point before any calls to List or Get.
	Authenticate(last interface{}) (TTL time.Duration, nextMetadata interface{}, err error)
}

const (
	typeUnknown int = iota
	typeVault
	typeOpsman
	typeCredhub
	typeTLS
)

const (
	TTLUnknown time.Duration = 0
	//TTLInfinite means that no further renewal is necessary, as the auth will
	//last forever
	TTLInfinite = time.Duration(0x7FFFFFFFFFFFFFFF)
)

//NewAccessor generates an accessor of the provided type, configured with the
//provided configuration object. returns the Accessor, the struct to be passed
//to the accessor's first auth call, and an error if one occurred.
func NewAccessor(accessorType string, conf map[string]interface{}) (
	Accessor,
	interface{},
	error,
) {
	properties, err := yaml.Marshal(&conf)
	if err != nil {
		panic("Could not re-marshal into YAML")
	}

	t := resolveType(strings.ToLower(accessorType))
	if t == typeUnknown {
		return nil, nil, fmt.Errorf("Unrecognized backend type (%s)", accessorType)
	}

	var c interface{}

	switch t {
	case typeVault:
		c = &VaultConfig{}
		err = yaml.Unmarshal(properties, c.(*VaultConfig))
	case typeOpsman:
		c = &OmConfig{}
		err = yaml.Unmarshal(properties, c.(*OmConfig))
	case typeCredhub:
		c = &ConfigServerConfig{}
		err = yaml.Unmarshal(properties, c.(*ConfigServerConfig))
	case typeTLS:
		c = &TLSClientConfig{}
		err = yaml.Unmarshal(properties, c.(*TLSClientConfig))
	}

	if err != nil {
		return nil, nil, fmt.Errorf("Error when parsing backend config: %s", err)
	}

	var backend Accessor
	var firstAuth interface{}
	switch t {
	case typeVault:
		backend, firstAuth, err = newVaultAccessor(*c.(*VaultConfig))
	case typeOpsman:
		backend, firstAuth, err = newOmAccessor(*c.(*OmConfig))
	case typeCredhub:
		backend, firstAuth, err = newConfigServerAccessor(*c.(*ConfigServerConfig))
	case typeTLS:
		backend, firstAuth, err = newTLSClientAccessor(*c.(*TLSClientConfig))
	}

	return backend, firstAuth, err
}

func resolveType(t string) int {
	switch t {
	case "vault":
		return typeVault
	case "opsmgr", "ops manager", "opsman", "opsmanager":
		return typeOpsman
	case "credhub", "configserver", "config server":
		return typeCredhub
	case "tls", "tlsclient":
		return typeTLS
	default:
		return typeUnknown
	}
}

$$--GLUE--$$
.\storage\configserver.go
$$--GLUE--$$
package storage

import (
	"crypto/x509"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"code.cloudfoundry.org/credhub-cli/credhub"
	"github.com/doomsday-project/doomsday/storage/uaa"
)

type ConfigServerAccessor struct {
	credhub      *credhub.CredHub
	uaaClient    *uaa.Client
	authType     uint64
	clientID     string
	clientSecret string
	username     string
	password     string
}

type ConfigServerConfig struct {
	Address            string `yaml:"address"`
	InsecureSkipVerify bool   `yaml:"insecure_skip_verify"`
	CACerts            string `yaml:"ca_certs"`
	Auth               struct {
		GrantType    string `yaml:"grant_type"`
		ClientID     string `yaml:"client_id"`
		ClientSecret string `yaml:"client_secret"`
		Username     string `yaml:"username"`
		Password     string `yaml:"password"`
	} `yaml:"auth"`
}

type configServerAuthMetadata struct {
	renewalDeadline time.Time
}

func newConfigServerAccessor(conf ConfigServerConfig) (
	*ConfigServerAccessor,
	configServerAuthMetadata,
	error,
) {
	metadata := configServerAuthMetadata{}

	credhubOpts := []credhub.Option{}
	if conf.InsecureSkipVerify {
		credhubOpts = append(credhubOpts, credhub.SkipTLSValidation(true))
	}

	if conf.CACerts != "" {
		credhubOpts = append(credhubOpts, credhub.CaCerts(conf.CACerts))
	}

	c, err := credhub.New(conf.Address, credhubOpts...)
	if err != nil {
		return nil, metadata, fmt.Errorf("Could not create config server client: %s", err)
	}
	c.Auth = &refreshTokenStrategy{APIClient: c.Client()}

	authURL, err := c.AuthURL()
	if err != nil {
		return nil, metadata, fmt.Errorf("Could not get auth endpoint: %s", err)
	}

	var authType uint64

	switch conf.Auth.GrantType {
	case "client_credentials", "client credentials", "clientcredentials":
		authType = uaa.AuthClientCredentials
	case "resource_owner", "resource owner", "resourceowner", "password":
		authType = uaa.AuthPassword
	case "none", "noop":
		authType = uaa.AuthNoop
	default:
		return nil, metadata, fmt.Errorf("Unknown auth grant_type `%s'", conf.Auth.GrantType)
	}

	certPool, _ := x509.SystemCertPool()
	if conf.CACerts != "" {
		certPool = x509.NewCertPool()
		ok := certPool.AppendCertsFromPEM([]byte(conf.CACerts))
		if !ok {
			return nil, metadata, fmt.Errorf("Could not parse provided CA certificates")
		}
	}

	ret := &ConfigServerAccessor{
		credhub: c,
		uaaClient: &uaa.Client{
			URL:               authURL,
			SkipTLSValidation: conf.InsecureSkipVerify,
			CACerts:           certPool,
		},
		authType:     authType,
		clientID:     conf.Auth.ClientID,
		clientSecret: conf.Auth.ClientSecret,
		username:     conf.Auth.Username,
		password:     conf.Auth.Password,
	}

	return ret, metadata, nil
}

//List attempts to get all of the paths in the config server
func (a *ConfigServerAccessor) List() (PathList, error) {
	paths, err := a.credhub.FindByPath("/")
	if err != nil {
		return nil, fmt.Errorf("Could not get paths in config server: %s", err)
	}

	ret := make(PathList, 0, len(paths.Credentials))
	for _, entry := range paths.Credentials {
		ret = append(ret, entry.Name)
	}

	return ret, nil
}

func (a *ConfigServerAccessor) Get(path string) (map[string]string, error) {
	cred, err := a.credhub.GetLatestVersion(path)
	if err != nil {
		return nil, err
	}

	if cred.Type != "certificate" &&
		cred.Type != "value" &&
		cred.Type != "json" {
		return nil, nil
	}

	ret := map[string]string{}
	a.walkForStrings(cred.Value, ret, []string{"value"})
	return ret, nil
}

func (a *ConfigServerAccessor) walkForStrings(value interface{}, agg map[string]string, path []string) {
	switch v := value.(type) {
	case string:
		agg[strings.Join(path, ".")] = v

	case map[string]interface{}:
		for pathSeg, nextVal := range v {
			a.walkForStrings(nextVal, agg, append(path, pathSeg))
		}

	case []interface{}:
		for pathSeg, nextVal := range v {
			a.walkForStrings(nextVal, agg, append(path, strconv.FormatInt(int64(pathSeg), 10)))
		}
	}
}

func (a *ConfigServerAccessor) Authenticate(last interface{}) (
	TTL time.Duration,
	next interface{},
	err error,
) {
	var authResp *uaa.AuthResponse
	metadata := last.(configServerAuthMetadata)

	switch a.authType {
	case uaa.AuthNoop:
		return TTLInfinite, metadata, nil

	case uaa.AuthClientCredentials:
		fmt.Fprintf(os.Stderr, "Performing client credentials auth for Credhub\n")
		authResp, err = a.uaaClient.ClientCredentials(a.clientID, a.clientSecret)

	case uaa.AuthPassword:
		attemptTime := time.Now()
		//The one second buffer is just so that we reduce the chance that we try
		// to renew the token just as the token is becoming unrenewable (and therefore err)
		if attemptTime.Add(1 * time.Second).Before(metadata.renewalDeadline) {
			fmt.Fprintf(os.Stderr, "Refreshing auth using refresh token for Credhub\n")
			authResp, err = a.uaaClient.Refresh(a.clientID, a.clientSecret, a.credhub.Auth.(*refreshTokenStrategy).RefreshToken())
		} else {
			fmt.Fprintf(os.Stderr, "Performing password auth for Credhub\n")
			authResp, err = a.uaaClient.Password(a.clientID, a.clientSecret, a.username, a.password)
		}

		if err == nil {
			metadata.renewalDeadline = attemptTime.Add(authResp.TTL)
		}

	default:
		panic("Unknown authType set in configServerAccessor")
	}
	if err != nil {
		return TTLUnknown, metadata, err
	}

	a.credhub.Auth.(*refreshTokenStrategy).SetTokens(authResp.AccessToken, authResp.RefreshToken)

	return authResp.TTL, metadata, nil
}

type refreshTokenStrategy struct {
	lock         sync.RWMutex
	accessToken  string
	refreshToken string
	APIClient    *http.Client
}

func (r *refreshTokenStrategy) Do(req *http.Request) (*http.Response, error) {
	req.Header.Set("Authorization", "Bearer "+r.AccessToken())
	return r.APIClient.Do(req)
}

func (r *refreshTokenStrategy) AccessToken() string {
	r.lock.RLock()
	defer r.lock.RUnlock()
	return r.accessToken
}

func (r *refreshTokenStrategy) RefreshToken() string {
	r.lock.RLock()
	defer r.lock.RUnlock()
	return r.refreshToken
}

func (r *refreshTokenStrategy) SetTokens(accessToken, refreshToken string) {
	r.lock.Lock()
	defer r.lock.Unlock()
	r.accessToken = accessToken
	r.refreshToken = refreshToken
}

$$--GLUE--$$
.\storage\opsmgr.go
$$--GLUE--$$
package storage

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"sync"
	"time"

	"github.com/doomsday-project/doomsday/storage/uaa"
)

type OmAccessor struct {
	client       *http.Client
	uaaClient    *uaa.Client
	url          *url.URL
	lock         sync.RWMutex
	clientID     string
	clientSecret string
	username     string
	password     string
	accessToken  string
	refreshToken string
	authType     uint64
}

type OmConfig struct {
	Address            string `yaml:"address"`
	InsecureSkipVerify bool   `yaml:"insecure_skip_verify"`
	CACerts            string `yaml:"ca_certs"`
	Auth               struct {
		GrantType    string `yaml:"grant_type"`
		Username     string `yaml:"username"`
		Password     string `yaml:"password"`
		ClientID     string `yaml:"client_id"`
		ClientSecret string `yaml:"client_secret"`
	} `yaml:"auth"`
}

type omAuthMetadata struct {
	renewalDeadline time.Time
}

func newOmClient(conf OmConfig) (*http.Client, error) {
	certPool, _ := x509.SystemCertPool()
	if conf.CACerts != "" {
		certPool = x509.NewCertPool()
		ok := certPool.AppendCertsFromPEM([]byte(conf.CACerts))
		if !ok {
			return nil, fmt.Errorf("Could not parse provided CA certificates")
		}
	}

	return &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyFromEnvironment,
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: conf.InsecureSkipVerify,
				RootCAs:            certPool,
			},
			Dial: (&net.Dialer{
				Timeout:   5 * time.Second,
				KeepAlive: 30 * time.Second,
			}).Dial,
		},
	}, nil
}

func newOmAccessor(conf OmConfig) (*OmAccessor, omAuthMetadata, error) {
	metadata := omAuthMetadata{}
	u, err := url.Parse(conf.Address)
	if err != nil {
		return nil, metadata, fmt.Errorf("could not parse target url: %s", err)
	}

	if u.Scheme == "" {
		u.Scheme = "https"
	}

	client, err := newOmClient(conf)
	if err != nil {
		return nil, metadata, err
	}

	certPool, _ := x509.SystemCertPool()
	if conf.CACerts != "" {
		certPool = x509.NewCertPool()
		ok := certPool.AppendCertsFromPEM([]byte(conf.CACerts))
		if !ok {
			return nil, metadata, fmt.Errorf("Could not parse provided CA certificates")
		}
	}

	var uaaClient = &uaa.Client{
		URL:               fmt.Sprintf("%s/uaa/oauth/token", u.String()),
		SkipTLSValidation: conf.InsecureSkipVerify,
		CACerts:           certPool,
	}

	var authType uint64

	switch conf.Auth.GrantType {
	case "client_credentials", "client credentials", "clientcredentials":
		authType = uaa.AuthClientCredentials
	case "resource_owner", "resource owner", "resourceowner", "password":
		authType = uaa.AuthPassword
	default:
		return nil, metadata, fmt.Errorf("Unknown auth grant_type `%s'", conf.Auth.GrantType)
	}

	ret := &OmAccessor{
		url:          u,
		uaaClient:    uaaClient,
		client:       client,
		clientID:     conf.Auth.ClientID,
		clientSecret: conf.Auth.ClientSecret,
		username:     conf.Auth.Username,
		password:     conf.Auth.Password,
		authType:     authType,
	}

	return ret, metadata, nil
}

//Get attempts to get the secret stored at the requested backend path and
// return it as a map.
func (v *OmAccessor) Get(path string) (map[string]string, error) {
	var credentials struct {
		Cred struct {
			Type  string            `json:"type"`
			Value map[string]string `json:"value"`
		} `json:"credential"`
	}

	respBody, err := v.opsmanAPI(path)
	if err != nil {
		return map[string]string{}, err
	}

	err = json.Unmarshal(respBody, &credentials)
	if err != nil {
		return map[string]string{}, fmt.Errorf("could not unmarshal credentials response: %s", err)
	}
	return credentials.Cred.Value, nil
}

//List attempts to list the paths in the ops manager that could have certs
func (v *OmAccessor) List() (PathList, error) {
	var finalPaths []string
	deployments, err := v.getDeployments()
	if err != nil {
		return []string{}, err
	}

	for _, deployment := range deployments {
		path := fmt.Sprintf("/api/v0/deployed/products/%s/credentials", deployment)

		var credentialReferences struct {
			Credentials []string `json:"credentials"`
		}

		respBody, err := v.opsmanAPI(path)
		if err != nil {
			return []string{}, err
		}

		err = json.Unmarshal(respBody, &credentialReferences)
		if err != nil {
			return []string{}, fmt.Errorf("could not unmarshal credentials response: %s\nresponse: `%s`", err, respBody)
		}

		for _, cred := range credentialReferences.Credentials {
			finalPaths = append(finalPaths, fmt.Sprintf("/api/v0/deployed/products/%s/credentials/%s", deployment, cred))
		}
	}

	return finalPaths, nil
}

func (v *OmAccessor) getDeployments() ([]string, error) {
	path := fmt.Sprintf("/api/v0/deployed/products")
	respBody, err := v.opsmanAPI(path)
	if err != nil {
		return []string{}, err
	}
	var rawDeployments []struct {
		InstallationName string `json:"installation_name"`
		GUID             string `json:"guid"`
		Type             string `json:"type"`
		ProductVersion   string `json:"product_version"`
	}

	err = json.Unmarshal(respBody, &rawDeployments)
	if err != nil {
		return []string{}, fmt.Errorf("could not unmarshal credentials response: %s\nresponse: `%s`", err, respBody)
	}

	var deployments []string
	for _, deployment := range rawDeployments {
		deployments = append(deployments, deployment.GUID)
	}

	return deployments, nil
}

func (v *OmAccessor) setTokens(accessToken, refreshToken string) {
	v.lock.Lock()
	defer v.lock.Unlock()
	v.accessToken = accessToken
	v.refreshToken = refreshToken
}

func (v *OmAccessor) getRefreshToken() string {
	v.lock.Lock()
	ret := v.refreshToken
	v.lock.Unlock()
	return ret
}

func (v *OmAccessor) Authenticate(last interface{}) (time.Duration, interface{}, error) {
	var authResp *uaa.AuthResponse
	var err error
	metadata := last.(omAuthMetadata)

	switch v.authType {
	case uaa.AuthClientCredentials:
		fmt.Fprintf(os.Stderr, "Performing client credentials auth for Ops Manager\n")
		authResp, err = v.uaaClient.ClientCredentials(v.clientID, v.clientSecret)

	case uaa.AuthPassword:
		attemptTime := time.Now()
		//The one second buffer is just so that we reduce the chance that we try
		// to renew the token just as the token is becoming unrenewable (and therefore err)
		if attemptTime.Add(1 * time.Second).Before(metadata.renewalDeadline) {
			fmt.Fprintf(os.Stderr, "Refreshing auth using refresh token for Ops Manager\n")
			authResp, err = v.uaaClient.Refresh(v.clientID, v.clientSecret, v.getRefreshToken())
		} else {
			fmt.Fprintf(os.Stderr, "Performing password auth for Ops Manager\n")
			authResp, err = v.uaaClient.Password(v.clientID, v.clientSecret, v.username, v.password)
		}

		if err == nil {
			metadata.renewalDeadline = attemptTime.Add(authResp.TTL)
		}

	default:
		panic("Unknown authType set in configServerAccessor")
	}
	if err != nil {
		return TTLUnknown, metadata, err
	}

	v.setTokens(authResp.AccessToken, authResp.RefreshToken)

	return authResp.TTL, metadata, nil
}

func (v *OmAccessor) opsmanAPI(path string) ([]byte, error) {
	u := *v.url
	u.Path = fmt.Sprintf("%s%s", u.Path, path)

	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return []byte{}, err
	}

	v.lock.RLock()
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", v.accessToken))
	v.lock.RUnlock()

	resp, err := v.client.Do(req)
	if err != nil {
		return []byte{}, fmt.Errorf("could not make api request to credentials endpoint: %s", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		reqDump, _ := httputil.DumpRequest(req, true)
		respDump, _ := httputil.DumpResponse(resp, true)
		return []byte{}, fmt.Errorf("%s\n\n%s", reqDump, respDump)
	}

	respBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return []byte{}, err
	}

	return respBody, nil
}

$$--GLUE--$$
.\storage\pathlist.go
$$--GLUE--$$
package storage

import (
	"regexp"
	"strings"
)

type PathList []string

//Multiple filters are "or"d together
type PathFilter struct {
	Under    []string
	Matching []string
}

func pathMatches(path, pattern string) bool {
	patternParts := strings.Split(pattern, "*")
	for i, p := range patternParts {
		patternParts[i] = regexp.QuoteMeta(p)
	}

	re := regexp.MustCompile(strings.Join(patternParts, `\A[^/:]*\Z`))
	return re.Match([]byte(path))
}

func pathIsUnder(path, dir string) bool {
	return strings.HasPrefix(strings.Trim(path, "/"), strings.TrimPrefix(dir, "/"))
}

//Doesn't modify reciever list
func (k PathList) Only(filter PathFilter) (ret PathList) {
OuterLoop:
	for _, key := range k {
		for _, match := range filter.Matching {
			if pathMatches(key, match) {
				ret = append(ret, key)
				continue OuterLoop
			}
		}

		for _, dir := range filter.Under {
			if pathIsUnder(key, dir) {
				ret = append(ret, key)
				continue OuterLoop
			}
		}
	}

	return
}

//Doesn't modify reciever list
func (k PathList) Except(filter PathFilter) (ret PathList) {
	for _, key := range k {
		var shouldNotAdd bool
		for _, match := range filter.Matching {
			if pathMatches(key, match) {
				shouldNotAdd = true
				goto DoneWithChecks
			}
		}

		for _, dir := range filter.Under {
			if pathIsUnder(key, dir) {
				shouldNotAdd = true
				goto DoneWithChecks
			}
		}

	DoneWithChecks:
		if !shouldNotAdd {
			ret = append(ret, key)
		}
	}

	return
}

$$--GLUE--$$
.\storage\tlsclient.go
$$--GLUE--$$
package storage

import (
	"crypto/tls"
	"encoding/pem"
	"fmt"
	"net"
	"net/url"
	"os"
	"regexp"
	"time"
)

type TLSClientAccessor struct {
	hosts   []string
	timeout time.Duration
}

type TLSClientConfig struct {
	Hosts   []string `yaml:"hosts"`
	Timeout int      `yaml:"timeout"`
}

func newTLSClientAccessor(conf TLSClientConfig) (*TLSClientAccessor, interface{}, error) {
	ret := &TLSClientAccessor{}
	if len(conf.Hosts) == 0 {
		return nil, nil, fmt.Errorf("No hosts list was specified in the configuration")
	}

	schemeRegex := regexp.MustCompile("^.+?://.+")
	for _, host := range conf.Hosts {

		toParse := host
		if !schemeRegex.Match([]byte(host)) {
			toParse = "garbage://" + host
		}

		thisURL, err := url.Parse(toParse)
		if err != nil {
			return nil, nil, fmt.Errorf("The configured hosts list contained an invalid URL (%s): %s", host, err)
		}

		if thisURL.Port() == "" {
			thisURL.Host = thisURL.Host + ":443"
		}

		ret.hosts = append(ret.hosts, thisURL.Host)
	}

	if conf.Timeout < 0 {
		conf.Timeout = 0
	}

	if conf.Timeout != 0 {
		ret.timeout = time.Second * time.Duration(conf.Timeout)
	}

	return ret, nil, nil
}

func (t *TLSClientAccessor) List() (PathList, error) {
	ret := make(PathList, 0, len(t.hosts))
	for _, host := range t.hosts {
		ret = append(ret, host)
	}

	return ret, nil
}

func (t *TLSClientAccessor) Get(host string) (map[string]string, error) {
	conn, err := tls.DialWithDialer(&net.Dialer{Timeout: t.timeout}, "tcp", host, &tls.Config{InsecureSkipVerify: true})
	if err != nil {
		//TODO: We should implement an actual warning system instead of just not
		// erroring
		//TODO: Also, we need to get the actual logger into these storage implementations
		fmt.Fprintf(os.Stderr, "Failed to connect to %s: %s\n", host, err)
		return nil, nil
	}

	certs := conn.ConnectionState().PeerCertificates
	ret := map[string]string{}
	if len(certs) != 0 {
		cert := certs[0].Raw
		pemCert := pem.EncodeToMemory(&pem.Block{
			Type:  "CERTIFICATE",
			Bytes: cert,
		})

		ret["cert"] = string(pemCert)
	}

	return ret, nil
}

func (t *TLSClientAccessor) Authenticate(_ interface{}) (time.Duration, interface{}, error) {
	return TTLInfinite, nil, nil
}

$$--GLUE--$$
.\storage\uaa\client.go
$$--GLUE--$$
package uaa

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"
)

const (
	AuthNoop = iota
	AuthClientCredentials
	AuthPassword
)

type Client struct {
	URL               string
	SkipTLSValidation bool
	CACerts           *x509.CertPool
}

func (c *Client) client() *http.Client {
	if c.CACerts == nil {
		c.CACerts, _ = x509.SystemCertPool()
	}

	return &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: c.SkipTLSValidation,
				RootCAs:            c.CACerts,
			},
			Dial: (&net.Dialer{
				Timeout:   5 * time.Second,
				KeepAlive: 30 * time.Second,
			}).Dial,
		},
	}
}

func (c *Client) do(values url.Values) (*AuthResponse, error) {
	req, err := http.NewRequest(
		"POST",
		fmt.Sprintf("%s/oauth/token", c.URL),
		strings.NewReader(values.Encode()),
	)

	if err != nil {
		return nil, err
	}

	req.Header.Add("Accept", "application/json")
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	resp, err := c.client().Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("Could not authenticate: Status %d", resp.StatusCode)
	}

	type response struct {
		AccessToken  string `json:"access_token"`
		RefreshToken string `json:"refresh_token"`
		ExpiresIn    int64  `json:"expires_in"`
	}

	r := response{}
	dec := json.NewDecoder(resp.Body)
	err = dec.Decode(&r)
	if err != nil {
		return nil, err
	}

	_, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return &AuthResponse{
		AccessToken:  r.AccessToken,
		RefreshToken: r.RefreshToken,
		TTL:          time.Second * time.Duration(r.ExpiresIn),
	}, nil
}

type AuthResponse struct {
	AccessToken  string
	RefreshToken string
	TTL          time.Duration
}

func (c *Client) ClientCredentials(
	clientID,
	clientSecret string) (*AuthResponse, error) {

	return c.do(url.Values{
		"grant_type":    []string{"client_credentials"},
		"client_id":     []string{clientID},
		"client_secret": []string{clientSecret},
	})
}

func (c *Client) Password(
	clientID,
	clientSecret,
	username,
	password string) (*AuthResponse, error) {

	return c.do(url.Values{
		"grant_type":    []string{"password"},
		"client_id":     []string{clientID},
		"client_secret": []string{clientSecret},
		"username":      []string{username},
		"password":      []string{password},
	})
}

func (c *Client) Refresh(
	clientID,
	clientSecret,
	refreshToken string) (*AuthResponse, error) {

	return c.do(url.Values{
		"grant_type":    []string{"refresh_token"},
		"client_id":     []string{clientID},
		"client_secret": []string{clientSecret},
		"refresh_token": []string{refreshToken},
	})
}

$$--GLUE--$$
.\storage\vault.go
$$--GLUE--$$
package storage

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/cloudfoundry-community/vaultkv"
)

const (
	vaultAuthToken uint = iota
	vaultAuthApprole
)

type VaultAccessor struct {
	client   *vaultkv.KV
	basePath string
	authType uint
	//roleID and secretID are used for AppRole authentication
	roleID   string
	secretID string
}

type VaultConfig struct {
	Address            string `yaml:"address"`
	InsecureSkipVerify bool   `yaml:"insecure_skip_verify"`
	CACerts            string `yaml:"ca_certs"`
	Namespace          string `yaml:"namespace"`
	BasePath           string `yaml:"base_path"`
	Trace              bool   `yaml:"trace"`
	Auth               struct {
		Token    string `yaml:"token"`
		RoleID   string `yaml:"role_id"`
		SecretID string `yaml:"secret_id"`
	} `yaml:"auth"`
}

type vaultAuthMetadata struct {
	renewalDeadline time.Time
	rootToken       bool
}

func newVaultAccessor(conf VaultConfig) (*VaultAccessor, vaultAuthMetadata, error) {
	if !regexp.MustCompile("^.*://").MatchString(conf.Address) {
		conf.Address = fmt.Sprintf("https://%s", conf.Address)
	}

	metadata := vaultAuthMetadata{}

	u, err := url.Parse(conf.Address)
	if err != nil {
		return nil, metadata, fmt.Errorf("Could not parse url (%s) in config: %s", conf.Address, err)
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, metadata, fmt.Errorf("Unsupported URL scheme `%s'", u.Scheme)
	}

	if conf.BasePath == "" {
		conf.BasePath = "secret/"
	}

	var tracer io.Writer
	if conf.Trace {
		//I'm already tracer
		tracer = os.Stdout
	}

	caPool, err := x509.SystemCertPool()
	if err != nil {
		caPool = nil
	}
	if conf.CACerts != "" {
		caPool = x509.NewCertPool()
		gotCerts := caPool.AppendCertsFromPEM([]byte(conf.CACerts))
		if !gotCerts {
			return nil, metadata, fmt.Errorf("CACerts property was provided, but no certificates were successfully parsed")
		}
	}

	client := &vaultkv.Client{
		VaultURL:  u,
		AuthToken: conf.Auth.Token,
		Client: &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: conf.InsecureSkipVerify,
					RootCAs:            caPool,
				},
				MaxIdleConnsPerHost: runtime.NumCPU(),
			},
		},
		Namespace: conf.Namespace,
		Trace:     tracer,
	}

	authType := vaultAuthToken
	if conf.Auth.RoleID != "" || conf.Auth.SecretID != "" {
		if conf.Auth.Token != "" {
			return nil, metadata, fmt.Errorf("Cannot provide both Token and AppRole authentication methods")
		}

		authType = vaultAuthApprole
	} else {
		attemptTime := time.Now()
		tokenInfo, err := client.TokenInfoSelf()
		if err != nil {
			return nil, metadata, fmt.Errorf("Could not get token info: %s", err)
		}

		if tokenInfo.ExpireTime.IsZero() {
			metadata.rootToken = true
		}

		metadata.renewalDeadline = attemptTime.Add(tokenInfo.TTL)
	}

	return &VaultAccessor{
		client:   client.NewKV(),
		basePath: conf.BasePath,
		authType: authType,
		roleID:   conf.Auth.RoleID,
		secretID: conf.Auth.SecretID,
	}, metadata, nil
}

//Get attempts to get the secret stored at the requested backend path and
// return it as a map.
func (v *VaultAccessor) Get(path string) (map[string]string, error) {
	ret := make(map[string]string)
	_, err := v.client.Get(path, &ret, nil)
	if err != nil {
		//This might be worth checking to see if
		// 1. The mount is v2
		// 2. The secret metadata exists
		// 3. The latest version is deleted
		// But for now, if we listed it, this is probably why we'd get a 404.
		if vaultkv.IsNotFound(err) {
			err = nil
		}
	}
	return ret, err
}

//List attempts to list all the paths under the configured base path
func (v *VaultAccessor) List() (PathList, error) {
	return v.list(v.basePath)
}

func (v *VaultAccessor) list(path string) (PathList, error) {
	var leaves []string
	list, err := v.client.List(path)
	if err != nil {
		return nil, err
	}

	for _, val := range list {
		if !strings.HasSuffix(val, "/") {
			leaves = append(leaves, canonizePath(fmt.Sprintf("%s/%s", path, val)))
		} else {
			rList, err := v.list(canonizePath(fmt.Sprintf("%s/%s", path, val)))
			if err != nil {
				return nil, err
			}
			leaves = append(leaves, rList...)
		}
	}

	return leaves, nil
}

func (v *VaultAccessor) Authenticate(last interface{}) (
	time.Duration,
	interface{},
	error,
) {
	lastMetadata := last.(vaultAuthMetadata)
	shouldRefresh := time.Now().Before(lastMetadata.renewalDeadline)
	var (
		ttl time.Duration
		err error
	)

	start := time.Now()

	switch v.authType {
	case vaultAuthToken:
		if lastMetadata.rootToken {
			return TTLInfinite, last, nil
		}
		ttl, err = v.authToken()

	case vaultAuthApprole:
		if shouldRefresh {
			ttl, err = v.authToken()
		} else {
			ttl, err = v.authApprole()
		}
	}
	if err != nil {
		return TTLUnknown, last, err
	}

	return ttl, vaultAuthMetadata{renewalDeadline: start.Add(ttl)}, nil
}

func (v *VaultAccessor) authToken() (ttl time.Duration, err error) {
	err = v.client.Client.TokenRenewSelf()
	if err != nil {
		err = fmt.Errorf("Could not renew token: %s", err)
		return
	}

	info, err := v.client.Client.TokenInfoSelf()
	if err != nil {
		err = fmt.Errorf("Error looking up token information after auth: %s", err)
		return
	}

	ttl = info.TTL
	return
}

func (v *VaultAccessor) authApprole() (ttl time.Duration, err error) {
	output, err := v.client.Client.AuthApprole(v.roleID, v.secretID)
	if err != nil {
		err = fmt.Errorf("Error performing AppRole authentication: %s", err)
		return
	}

	ttl = output.LeaseDuration
	return
}

func canonizePath(path string) string {
	pathChunks := strings.Split(path, "/")
	for i := 0; i < len(pathChunks); i++ {
		if pathChunks[i] == "" {
			pathChunks = append(pathChunks[:i], pathChunks[i+1:]...)
			i--
		}
	}
	return strings.Join(pathChunks, "/")
}

$$--GLUE--$$
.\version\version.go
$$--GLUE--$$
package version

//Version is the version of this doomsday tool, typically set at linker time
// by the Makefile
var Version = "unknown"

$$--GLUE--$$
.\web\build\doomsday.js
$$--GLUE--$$
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["NONE"] = 0] = "NONE";
    AuthMethod[AuthMethod["USERPASS"] = 1] = "USERPASS";
})(AuthMethod || (AuthMethod = {}));
;
class APIError {
    constructor(errorMessage, returnCode) {
        this.errorMessage = errorMessage;
        this.returnCode = returnCode;
        this.error = errorMessage;
        this.code = returnCode;
    }
}
class Doomsday {
    doRequest(method, path, data) {
        return fetch(path, {
            method: method,
            credentials: "same-origin",
            headers: {
                "Content-Type": "application/json"
            },
            body: data ? JSON.stringify(data) : undefined,
        })
            .catch(() => { throw new APIError("Unexpected fetch error", 0); })
            .then(resp => {
            if (resp.ok) {
                return resp.json();
            }
            throw new APIError(resp.statusText, resp.status);
        }).catch(e => {
            if (e instanceof APIError) {
                throw e;
            }
            throw new APIError("JSON parsing failed", 0);
        });
    }
    fetchAuthType() {
        return this.doRequest("GET", "/v1/info")
            .then(data => (data.auth_type == "Userpass" ? AuthMethod.USERPASS : AuthMethod.NONE));
    }
    authUser(username, password) {
        return this.doRequest("POST", "/v1/auth", {
            username: username,
            password: password
        });
    }
    fetchCerts() {
        return this.doRequest("GET", "/v1/cache")
            .then(data => {
            let ret = [];
            for (let cert of data.content) {
                ret.push($.extend(new Certificate(), cert));
            }
            return ret;
        });
    }
}
class Certificate {
    get commonName() { return this.common_name; }
    get notAfter() { return this.not_after; }
}
class CertificateStoragePath {
}
class Color {
    constructor(red, green, blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }
    get 0() { return this.red; }
    get 1() { return this.green; }
    get 2() { return this.blue; }
    hex() {
        return "#" + this.cAsHex(this.red) + this.cAsHex(this.green) + this.cAsHex(this.blue);
    }
    shift(c2, percent) {
        return new Color(this.red + ((c2.red - this.red) * percent), this.green + ((c2.green - this.green) * percent), this.blue + ((c2.blue - this.blue) * percent));
    }
    cAsHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
        ;
    }
}
var Colors;
(function (Colors) {
    Colors.Black = new Color(0, 0, 0);
    Colors.Red = new Color(229, 53, 69);
    Colors.Orange = new Color(253, 126, 20);
    Colors.OrangeYellow = new Color(255, 193, 7);
    Colors.Yellow = new Color(200, 185, 15);
    Colors.Green = new Color(40, 167, 69);
})(Colors || (Colors = {}));
function getCookie(name) {
    let state = 0;
    let length = document.cookie.length;
    let found = false;
    let key = "";
    let value = "";
    function checkKey() {
        if (key == name) {
            found = true;
        }
        else {
            key = "";
            value = "";
            state = 2;
        }
    }
    for (let i = 0; i < length && !found; i++) {
        let c = document.cookie.charAt(i);
        switch (state) {
            case 0:
                if (c == '=') {
                    state = 1;
                }
                else if (c == ';') {
                    value = key;
                    key = "";
                    checkKey();
                }
                else {
                    key = key + c;
                }
                break;
            case 1:
                if (c == ';') {
                    checkKey();
                }
                else {
                    value = value + c;
                }
                break;
            case 2:
                if (c == '=') {
                    key = "";
                    state = 1;
                }
                else if (c == ';') {
                    key = "";
                    value = "";
                    checkKey();
                }
                else if (c != ' ' && c != '\t') {
                    key = c;
                    state = 0;
                }
                break;
        }
    }
    if (!found && key != name) {
        value = "";
    }
    return value;
}
function deleteCookie(name) {
    document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
}
class Pager {
    constructor(client) {
        this.ctx = {
            client: client,
            hamburgerMenu: $("#hamburger-box"),
            pager: this
        };
    }
    display(page) {
        if (this.curPage != null) {
            this.curPage.teardown();
        }
        this.curPage = page;
        page.setContext(this.ctx);
        if (page.settings && page.settings.hideHamburgerMenu) {
            this.ctx.hamburgerMenu.hide();
        }
        else {
            this.ctx.hamburgerMenu.show();
        }
        page.initialize();
    }
}
class PageContext {
}
class PageBase {
    setContext(ctx) {
        this.ctx = ctx;
    }
    get settings() {
        return this._settings;
    }
}
class PageSettings {
}
class LoginPage extends PageBase {
    constructor(message) {
        super();
        this.message = message;
        this._settings = {
            hideHamburgerMenu: true
        };
    }
    initialize() {
        var templateParams = {};
        if (this.message) {
            templateParams.error_message = this.message;
        }
        this.login = $("#login");
        this.login.template("login-page", templateParams);
        this.loginForm = $("#login-form");
        this.loginFormUsername = $("#login-form input[name=username]");
        this.loginFormPassword = $("#login-form input[name=password]");
        this.loginForm.submit(this.getLoginHandler());
        this.login.show();
    }
    teardown() {
        this.login.hide();
        this.loginForm.off("submit");
    }
    getLoginHandler() {
        let self = this;
        return function (e) {
            let username = self.loginFormUsername.val();
            let password = self.loginFormPassword.val();
            self.loginFormPassword.val("");
            self.ctx.client.authUser(username, password)
                .then(() => {
                self.ctx.pager.display(new DashboardPage());
            })
                .catch(e => {
                if (e.code == 401) {
                    self.ctx.pager.display(new LoginPage("The username and password did not match"));
                }
                else {
                    self.ctx.pager.display(new LoginPage("Something went wrong!"));
                    console.log(`Something went wrong: ${e.errorMessage}`);
                }
            });
            return false;
        };
    }
}
class DashboardPage extends PageBase {
    constructor() {
        super();
        this.certUpdateID = -1;
        this.certsElement = $("#certs");
    }
    initialize() {
        this.certsElement.show();
        this.certs = new CertificateList();
        this.updateCertList();
    }
    teardown() {
        clearTimeout(this.certUpdateID);
        this.certUpdateID = -1;
        this.certsElement.hide();
        this.showMoreButton.off();
    }
    updateCertList() {
        this.ctx.client.fetchCerts()
            .then((content) => {
            this.certs = new CertificateList(content);
            this.repaint();
            this.certUpdateID = setTimeout(this.updateCertList.bind(this), 60 * 1000);
        })
            .catch(e => {
            if (e.code == 401) {
                deleteCookie('doomsday-token');
                this.ctx.pager.display(new LoginPage("Your session has expired"));
            }
            else {
                this.ctx.pager.display(new LoginPage("Something went wrong!"));
                console.log(`Something went wrong: ${e.errorMessage}`);
            }
        });
    }
    repaint() {
        let now = new Date().getTime() / 1000;
        let lists = [];
        let certsToDisplay = this.certs;
        if (!this.shouldShowAll) {
            certsToDisplay = this.certs.expiresWithin(DashboardPage.DEFAULT_EXPIRY_CUTOFF);
        }
        for (let cert of certsToDisplay) {
            if (lists.length == 0 || cert.notAfter > lists[lists.length - 1].cutoff) {
                let maxDays = Math.max(0, Math.ceil((cert.not_after - now) / 86400));
                let label = this.durationString(maxDays - 1);
                lists.push({
                    header: label,
                    cutoff: now + (maxDays * 86400),
                    color: this.cardColor(maxDays - 1),
                    certs: [cert]
                });
            }
            else {
                lists[lists.length - 1].certs.push(cert);
            }
        }
        if (lists.length == 0) {
            this.certsElement.template("no-certs-page");
        }
        else {
            this.certsElement.template("cert-list-group", { lists: lists });
            this.certsElement.show();
        }
        this.showMoreButton = $("#certs-show-more");
        this.showMoreButton.on("click", (e) => {
            e.preventDefault();
            this.showMoreButton.prop("disabled", true);
            this.showMoreButton.html("working...");
            this.shouldShowAll = !this.shouldShowAll;
            this.repaint();
            this.showMoreButton = $("#certs-show-more");
            this.showMoreButton.html("show " + (this.shouldShowAll ? "less" : "all"));
            this.showMoreButton.prop("disabled", false);
            return false;
        });
        return;
    }
    durationString(days) {
        if (days < 0) {
            return "THE DAWN OF TIME";
        }
        else if (days == 0) {
            return "NOW";
        }
        else if (days == 1) {
            return "1 DAY";
        }
        else if (days < 7) {
            return days + " DAYS";
        }
        else {
            var weeks = Math.floor(days / 7);
            var remaining_days = days - (weeks * 7);
            var ret = weeks + " WEEKS";
            if (weeks == 1) {
                ret = "1 WEEK";
            }
            if (remaining_days > 0) {
                ret = ret + ", " + this.durationString(remaining_days);
            }
            return ret;
        }
    }
    cardColor(days) {
        if (days < 0) {
            return Colors.Black;
        }
        else if (days < 3) {
            return Colors.Red;
        }
        else if (days < 7) {
            return Colors.Red.shift(Colors.Orange, 1 - ((7 - days) / 4));
        }
        else if (days < 14) {
            return Colors.Orange.shift(Colors.OrangeYellow, 1 - ((14 - days) / 7));
        }
        else if (days < 21) {
            return Colors.OrangeYellow.shift(Colors.Yellow, 1 - ((21 - days) / 7));
        }
        else if (days < 28) {
            return Colors.Yellow.shift(Colors.Green, 1 - ((28 - days) / 7));
        }
        return Colors.Green;
    }
}
DashboardPage.DEFAULT_EXPIRY_CUTOFF = 7776000;
class CertificateList {
    constructor(initial) {
        this.storage = [];
        if (initial) {
            this.storage = initial;
        }
    }
    [Symbol.iterator]() {
        const now = new Date().getTime() / 1000;
        const maxUntil = (typeof this.expMax === 'number' ? this.expMax : Number.MAX_VALUE);
        let idx = 0;
        return {
            next: () => {
                let isDone = () => {
                    if (idx >= this.storage.length) {
                        return true;
                    }
                    if (this.storage[idx].notAfter - now > maxUntil) {
                        return true;
                    }
                    return false;
                };
                let done = isDone();
                return {
                    done: done,
                    value: done ? undefined : this.storage[idx++]
                };
            }
        };
    }
    get length() { return this.storage.length; }
    expiresWithin(duration) {
        let ret = new CertificateList(this.storage);
        ret.expMax = duration;
        return ret;
    }
}
let NORMAL_HAMBURGER_WIDTH;
let NORMAL_HAMBURGER_HEIGHT;
let HAMBURGER_BOX_PADDING;
$(document).ready(function () {
    let hamburgerBox = $('#hamburger-box');
    NORMAL_HAMBURGER_WIDTH = hamburgerBox.width();
    NORMAL_HAMBURGER_HEIGHT = $('#hamburger').height();
    HAMBURGER_BOX_PADDING = hamburgerBox.innerWidth() - NORMAL_HAMBURGER_WIDTH;
    let doomsday = new Doomsday();
    let pager = new Pager(doomsday);
    doomsday.fetchAuthType()
        .then(authType => {
        if (authType == AuthMethod.NONE) {
            let logout_button = $('#logout-button');
            logout_button.addClass('hamburger-menu-button-inactive');
            logout_button.removeClass('navbar-button hamburger-menu-button');
            logout_button.mouseover(function () { logout_button.text('auth is turned off'); });
            logout_button.mouseout(function () { logout_button.text('logout'); });
        }
        else {
            $('#logout-button').click(function () {
                closeHamburgerMenu();
                deleteCookie('doomsday-token');
                pager.display(new LoginPage());
            });
        }
        if (authType == AuthMethod.USERPASS && getCookie('doomsday-token') == "") {
            pager.display(new LoginPage());
        }
        else {
            pager.display(new DashboardPage());
        }
    })
        .catch((e) => {
        console.log(`Something went wrong: ${e.errorMessage}`);
    });
});
const FRAMERATE = 42;
const FRAME_INTERVAL = 1000 / FRAMERATE;
const NO_ANIM = -1;
let hamburgerMenuOpen = false;
let currentHamburgerMenuOpenness = 0;
function setHamburgerMenuOpenness(percentage) {
    let menu = $('#hamburger-menu');
    let menuWidth = menu.innerWidth() + 1;
    let desiredShift = menuWidth * percentage;
    menu.css('left', (-menuWidth + desiredShift) + "px");
    let boxWidth = Math.max(desiredShift - (1 + HAMBURGER_BOX_PADDING), NORMAL_HAMBURGER_WIDTH);
    let boxHeight = NORMAL_HAMBURGER_HEIGHT - (percentage * (NORMAL_HAMBURGER_HEIGHT * 0.1));
    $('#hamburger-box').css('width', boxWidth + "px");
    $('#hamburger').css('height', boxHeight + "px");
    currentHamburgerMenuOpenness = percentage;
}
let menuOpenAnimID = NO_ANIM;
function hamburgerMenuSlide(start, end) {
    if (menuOpenAnimID != NO_ANIM) {
        clearInterval(menuOpenAnimID);
    }
    let duration = 0.2;
    let totalDelta = end - start;
    let lastAnimTime = new Date().getTime();
    return function () {
        let now = new Date().getTime();
        let timeDelta = now - lastAnimTime;
        let updatePercentage = (duration * 1000) / timeDelta;
        let frameDelta = totalDelta / updatePercentage;
        lastAnimTime = now;
        let desiredOpenness = currentHamburgerMenuOpenness + frameDelta;
        if ((totalDelta >= 0 && desiredOpenness >= end) || (totalDelta < 0 && desiredOpenness <= end)) {
            desiredOpenness = end;
            clearInterval(menuOpenAnimID);
            menuOpenAnimID = NO_ANIM;
        }
        setHamburgerMenuOpenness(desiredOpenness);
    };
}
function openHamburgerMenu() {
    menuOpenAnimID = setInterval(hamburgerMenuSlide(0, 1), FRAME_INTERVAL);
    hamburgerMenuOpen = true;
}
function closeHamburgerMenu() {
    menuOpenAnimID = setInterval(hamburgerMenuSlide(1, 0), FRAME_INTERVAL);
    hamburgerMenuOpen = false;
}
function toggleHamburgerMenu() {
    if (hamburgerMenuOpen) {
        closeHamburgerMenu();
    }
    else {
        openHamburgerMenu();
    }
}
$('#hamburger-box').click(function () {
    toggleHamburgerMenu();
});

$$--GLUE--$$
.\web\embed\main.go
$$--GLUE--$$
package main

import (
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"text/template"

	yaml "gopkg.in/yaml.v2"
)

const (
	tmpl = `package server

type staticFile struct {
	Content []byte
	MIMEType string
}

// This file is autogenerated by go generate. Do not modify.
var webStatics = map[string]staticFile{ {{range .}}
	"{{.Path}}": ` + "{ Content: {{.Content}}, MIMEType: `{{.MIMEType}}` }," + `{{end}}
}
`
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Must give mappings file as argument.")
		os.Exit(1)
	}

	mappingsFilePath := os.Args[1]
	mappingsFile, err := os.Open(mappingsFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not open mappings file `%s'\n", mappingsFilePath)
		os.Exit(1)
	}

	type mappingsFileEntry struct {
		ServePath string `yaml:"servePath"`
		MIMEType  string `yaml:"mimeType"`
	}

	mappings := map[string]mappingsFileEntry{}
	yamlDecoder := yaml.NewDecoder(mappingsFile)
	err = yamlDecoder.Decode(&mappings)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not decode mappings file `%s' as YAML: %s\n", mappingsFilePath, err)
		os.Exit(1)
	}

	type staticFile struct {
		Path string

		Content  string
		MIMEType string
	}
	staticFiles := []staticFile{}
	for filepathToRead, value := range mappings {
		f, err := os.Open(filepathToRead)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not open static file `%s'\n", filepathToRead)
			os.Exit(1)
		}

		fileContentsBytes, err := ioutil.ReadAll(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not read static file `%s'\n", filepathToRead)
			os.Exit(1)
		}

		fmt.Println("Starting " + filepathToRead)
		asByteArray := []byte("[]byte{")
		for i, b := range fileContentsBytes {
			if i%16 == 0 {
				// linefeed
				asByteArray = append(asByteArray, 0x0A)
			}
			bHex := make([]byte, 2)
			hex.Encode(bHex, []byte{b})
			//0x<hex> comma
			asByteArray = append(asByteArray, 0x30, 0x78, bHex[0], bHex[1], 0x2C)
		}

		// newline and }
		asByteArray = append(asByteArray, 0x0A, 0x7D)

		fmt.Println("Done with " + filepathToRead)

		staticFiles = append(staticFiles, staticFile{
			Path:     value.ServePath,
			MIMEType: value.MIMEType,
			Content:  string(asByteArray),
		})
	}

	//Make sure the static files get written in a determinstic order
	sort.Slice(staticFiles, func(i, j int) bool { return staticFiles[i].Path < staticFiles[j].Path })

	t := template.Must(template.New("genstaticmap").Parse(tmpl))

	outputFile, err := os.Create("server/static.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not create output file: %s\n", err)
		os.Exit(1)
	}

	err = t.Execute(outputFile, staticFiles)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not execute template: %s\n", err)
		os.Exit(1)
	}
}

$$--GLUE--$$
.\web\embed\mappings.yml
$$--GLUE--$$
web/index.html:
  servePath: /
  mimeType: text/html
web/stylesheet.css:
  servePath: /web/assets/stylesheet.css
  mimeType: text/css
web/fonts.css:
  servePath: /web/assets/fonts.css
  mimeType: text/css
web/include/lens.js:
  servePath: /web/assets/lens.js
  mimeType: application/javascript
web/include/jquery-3.5.1.min.js:
  servePath: /web/assets/jquery-3.5.1.min.js
  mimeType: application/javascript
web/fonts/Pangolin/Pangolin-Regular.ttf:
  servePath: /web/assets/fonts/Pangolin.ttf
  mimeType: font/opentype
web/fonts/Walter_Turncoat/WalterTurncoat-Regular.ttf:
  servePath: /web/assets/fonts/WalterTurncoat.ttf
  mimeType: font/opentype
web/build/doomsday.js:
  servePath: /web/assets/js/doomsday.js
  mimeType: application/javascript

$$--GLUE--$$
.\web\fonts\Pangolin\OFL.txt
$$--GLUE--$$
Copyright 2016 The Pangolin Project Authors (https://github.com/googlefonts/pangolin)

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

$$--GLUE--$$
.\web\fonts\Walter_Turncoat\LICENSE.txt
$$--GLUE--$$

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

$$--GLUE--$$
.\web\fonts.css
$$--GLUE--$$

/* latin */
@font-face {
  font-family: 'Walter Turncoat';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Walter Turncoat Regular'), local('WalterTurncoat-Regular'), url(fonts/WalterTurncoat.ttf) format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Pangolin';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Pangolin Regular'), local('Pangolin-Regular'), url(fonts/Pangolin.ttf) format('ttf');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
/* cyrillic */
@font-face {
  font-family: 'Pangolin';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Pangolin Regular'), local('Pangolin-Regular'), url(fonts/Pangolin.ttf) format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* vietnamese */
@font-face {
  font-family: 'Pangolin';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Pangolin Regular'), local('Pangolin-Regular'), url(fonts/Pangolin.ttf) format('truetype');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Pangolin';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Pangolin Regular'), local('Pangolin-Regular'), url(fonts/Pangolin.ttf) format('truetype');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Pangolin';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Pangolin Regular'), local('Pangolin-Regular'), url(fonts/Pangolin.ttf) format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
$$--GLUE--$$
.\web\include\jquery-3.5.1.min.js
$$--GLUE--$$
/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});

$$--GLUE--$$
.\web\include\lens.js
$$--GLUE--$$
var Lens = {};
;(function () {

  var nil = function () { };

  if (!console) {
    console = { log: nil };
  }

  var log = {
    debug: nil,
    info:  nil,
    warn:  nil,
    error: nil,

    level: function (level) {
      log.debug = nil;
      log.info  = nil;
      log.warn  = nil;
      log.error = nil;

      switch (level) {
      case 'debug': log.debug = console.log;
      case 'info':  log.info  = console.log;
      case 'warn':  log.warn  = console.log;
      case 'error': log.error = console.log;
      }
    }
  };

  Lens.log = log;
})()
;(function () {
  const SET_ATTRIBUTE    = 1,
        REMOVE_ATTRIBUTE = 2,
        SET_PROPERTY     = 3,
        REMOVE_PROPERTY  = 4,
        REPLACE_NODE     = 5,
        APPEND_CHILD     = 6,
        REMOVE_CHILD     = 7,
        REPLACE_TEXT     = 8;

  /* diff the ATTRIBUTES of two nodes, and return a
     (potentially empty) patch op list. */
  var diffa = function (a, b) {
    const ops = [];
    const _a  = {};
    const _b  = {};

    for (let i = 0; i < a.attributes.length; i++) {
      _a[a.attributes[i].nodeName] = a.attributes[i].nodeValue;
    }
    for (let i = 0; i < b.attributes.length; i++) {
      _b[b.attributes[i].nodeName] = b.attributes[i].nodeValue;
    }

    /* if the attribute is only defined in (a), then
       it has been removed in (b) and should be patched
       as a REMOVE_ATTRIBUTE.  */
    for (let attr in _a) {
      if (!(attr in _b)) {
        ops.push({
          op:    REMOVE_ATTRIBUTE,
          node:  a,
          key:   attr,
        });
      }
    }

    /* if the attribute is only defined in (b), or is
       defined in both with different values, patch as
       a SET_ATTRIBUTE to get the correct value. */
    for (let attr in _b) {
      if (!(attr in _a) || _a[attr] !== _b[attr]) {
        ops.push({
          op:    SET_ATTRIBUTE,
          node:  a,
          key:   attr,
          value: _b[attr]
        });
      }
    }

    return ops;
  };

  var diffe = function (a, b) {
    if (a.localName === b.localName) {
      return diffa(a, b);
    }
    return null;
  };

  var difft = function (a, b) {
    if (a.textContent === b.textContent) {
      return [];
    }
    return [{
      op:   REPLACE_TEXT,
      node: a,
      with: b.textContent
    }];
  };

  /* diff two NODEs, without recursing through child nodes */
  var diffn1 = function (a, b) {
    if (a.nodeType != b.nodeType) {
      /* nothing in common */
      return null;
    }

    if (a.nodeType == Node.ELEMENT_NODE) {
      return diffe(a, b);
    }
    if (a.nodeType == Node.TEXT_NODE) {
      return difft(a, b);
    }
    if (a.nodeType == Node.COMMENT_NODE) {
      return null;
    }

    console.log('unrecognized a type %s', a.nodeType);
    return null;
  };

  /* diff two NODEs, co-recursively with diff() */
  var diffn = function (a, b) {
    let ops = diffn1(a, b);

    if (ops) {
      return ops.concat(diff(a, b));
    }

    return [{
      op:   REPLACE_NODE,
      node: a,
      with: b
    }];
  };

  window.diff = function (a, b) {
    let ops = [];
    const { childNodes: _a } = a;
    const { childNodes: _b } = b;

    const _al = _a ? _a.length : 0;
    const _bl = _b ? _b.length : 0;

    for (let i = 0; i < _bl; i++) {
      if (!_a[i]) {
        ops.push({
          op:    APPEND_CHILD,
          node:  a,
          child: _b[i]
        });
        continue;
      }

      ops = ops.concat(diffn(_a[i], _b[i]));
    }

    for (var i = _bl; i < _al; i++) {
      ops.push({
        op:    REMOVE_CHILD,
        node:  a,
        child: _a[i]
      });
    }

    return ops;
  };




  window.patch = function (e, ops) {
    for (let i = 0; i < ops.length; i++) {
      switch (ops[i].op) {
        case SET_ATTRIBUTE:    ops[i].node.setAttribute(ops[i].key, ops[i].value);            break;
        case REMOVE_ATTRIBUTE: ops[i].node.removeAttribute(ops[i].key);                       break;
        case SET_PROPERTY:     /* FIXME needs implemented! */                                 break;
        case REMOVE_PROPERTY:  /* FIXME needs implemented! */                                 break;
        case REPLACE_NODE:     ops[i].node.parentNode.replaceChild(ops[i].with, ops[i].node); break;
        case APPEND_CHILD:     ops[i].node.appendChild(ops[i].child);                         break;
        case REMOVE_CHILD:     ops[i].node.removeChild(ops[i].child);                         break;
        case REPLACE_TEXT:     ops[i].node.textContent = ops[i].with;                         break;
        default:
          console.log('unrecognized patch op %d for ', ops[i].op, ops[i]);
          break;
      }
    }
  };




  window.explainPatch = function (ops) {
    var l = [];
    for (let i = 0; i < ops.length; i++) {
      switch (ops[i].op) {
        case SET_ATTRIBUTE:    l.push(['SET_ATTRIBUTE',    ops[i].node, ops[i].key+'='+ops[i].value]); break;
        case REMOVE_ATTRIBUTE: l.push(['REMOVE_ATTRIBUTE', ops[i].node, ops[i].key]);                  break;
        case SET_PROPERTY:     l.push(['SET_PROPERTY',     'FIXME']);                                  break;
        case REMOVE_PROPERTY:  l.push(['REMOVE_PROPERTY',  'FIXME']);                                  break;
        case REPLACE_NODE:     l.push(['REPLACE_NODE',     ops[i].node, { with: ops[i].with }]);       break;
        case APPEND_CHILD:     l.push(['APPEND_CHILD',     ops[i].node, { child: ops[i].child }]);     break;
        case REMOVE_CHILD:     l.push(['REMOVE_CHILD',     ops[i].node, { child: ops[i].child }]);     break;
        case REPLACE_TEXT:     l.push(['REPLACE_TEXT',     ops[i].node, { with: ops[i].with }]);       break;
        default:               l.push(['**UNKNOWN**',      ops[i]]);                                   break;
      }
    }
    return l;
  };
})(window, document);
;(function () {

  var __templates = {};
  var template = function (name, data) {
    if (!(name in __templates)) {
      Lens.log.debug('template {%s} not found in the cache; compiling from source.', name);
      __templates[name] = compile(name);
    }

    return __templates[name](data || {});
  };

  var parse = function (src) {
    var tokenizer = new RegExp('([\\s\\S]*?)\\[\\[([\\s\\S]*?)\\]\\]([\\s\\S]*)');
    var str = function (s) {
      if (!s) { return "''"; }
      return "'"+s.replace(/(['\\])/g, '\\$1').replace(/\n/g, "\\n")+"'";
    };

    var code = [];
    for (;;) {
      var tokens = tokenizer.exec(src)
      if (!tokens) {
        code.push('__ += '+str(src)+';');
        break;
      }

      if (tokens[2][0] == ':') { /* trim preceeding literal */
        tokens[1] = tokens[1].replace(/\s+$/, '');
        tokens[2] = tokens[2].substr(1);
      }
      if (tokens[2][tokens[2].length - 1] == ':') { /* trim following literal */
        tokens[3] = tokens[3].replace(/^\s+/, '');
        tokens[2] = tokens[2].substr(0, tokens[2].length-2);
      }

      code.push('__ += '+str(tokens[1])+';');
      if (tokens[2][0] == '=') {
        code.push('__ += ('+tokens[2].replace(/^=\s*/, '')+');');

      } else if (tokens[2][0] != '#') { /* skip comments */
        code.push(tokens[2]);
      }

      src = tokens[3];
    }

    return code.join('');
  };

  var compile = function (name) {
    name = name.toString();
    var script = document.getElementById('template:'+name);
    if (!script) {
      Lens.log.error('unable to find a <script> element with id="template:%s"', name);
      return function () {
        throw "Template {"+name+"} not found";
      };
    }

    var code = parse(script.innerHTML);

    return function (_) {
      /* the output variable */
      var __ = '';

      /* namespaced helper functions */
      var lens = {



        /* maybe(x,fallback)

           fallback to a default value if a given variable
           is undefined, or was not provided.

           example:

             [[= lens.maybe(x, "no x given") ]]

         */
        maybe: function (a, b) {
          return typeof(a) !== 'undefined' ? a : b;
        },

        /* escapeHTML(x)

           return a sanitized version of x, with the dangerous HTML
           entities like <, > and & replaced.  Also replaces double
           quote (") with the &quot; representation, so that you can
           embed values in form element attributes.

           example:

             <input type="text" name="display"
                    value="[[= lens.htmlEscape(_.display) ]]">

           lens.h() is an alias, so you can also do this:

             <input type="text" name="display"
                    value="[[= lens.h(_.display) ]]">
         */
        escapeHTML: function (s) {
          var t = document.createElement('textarea');
          t.innerText = s;
          return t.innerHTML.replace(/"/g, '&quot;');
        },

        /* include(template)
           include(template, _.other.data)

           splices the output of another template into the current
           output, at the calling site.  This can be useful for
           breaking up common elements of a UI into more manageable
           chunks.

           example:

             <div id="login">[[ lens.include('signin'); ]]</div>

           you can also provide a data object that will become the
           `_` variable inside the called template:

             [[ lens.include('alert', { alert: "something broke" }); ]]

           as a "language construct", this function is also aliased
           as (toplevel) `include()`, and it can be used in [[= ]]
           constructs:

             [[= include('other-template') ]]

         */
        include: function (name, data) {
          __ += template(name, data || _);
          return '';
        }
      };

      /* aliases ... */
      lens.u = encodeURIComponent;
      lens.h = lens.escapeHTML;
      var include = lens.include;

      Lens.log.debug('evaluating the {%s} template', name);
      eval(code);
      return __;
    };
  };

  window.parseTemplate = parse;

  if (typeof(jQuery) !== 'undefined') {
    jQuery.template = template;

    jQuery.fn.template = function (name, data, force) {
      if (force || this.length == 0) {
        this.html(template(name, data));
      } else {
        window.patch(this[0], diff(this[0], $('<div>'+template(name, data)+'</div>')[0]));
      }
      return this;
    };

  } else if (typeof(window) !== 'undefined') {
    window.template = template;

  } else {
    throw 'neither jQuery or top-level window object were found; unsure where to attach template()...';
  }
})();
;(function () {
  var strftime = function (fmt, d) {
    if (!(d instanceof Date)) {
      var _d = new Date();
      if (!isNaN(d)) {
        _d.setTime(d * 1000); /* epoch s -> ms */
      }
      d = _d;
    }
    if (typeof(d) === 'undefined') {
      return "";
    }

    en_US = {
      pref: {
        /* %c */ datetime: function (d) { return strftime("%a %b %e %H:%M:%S %Y", d); },
        /* %x */ date:     function (d) { return strftime("%m/%d/%Y", d); },
        /* %X */ time:     function (d) { return strftime("%H:%M:%S", d); }
      },
      weekday: {
        abbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        full: ['Sunday',
               'Monday',
               'Tuesday',
               'Wednesday',
               'Thursday',
               'Friday',
               'Saturday']
      },
      month: {
        abbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        full: ['January',
               'February',
               'March',
               'April',
               'May',
               'June',
               'July',
               'August',
               'September',
               'October',
               'November',
               'December']
      },
      AM: "AM", am: "am", PM: "PM", pm: "pm",
      ordinal: ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', //  1 - 10
                      'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', // 11 - 20
                      'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', // 21 - 30
                      'st'],
      zero:  ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09',
              '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
              '20', '21', '22', '23', '24', '25', '26', '27', '28', '29',
              '30', '31', '32', '33', '34', '35', '36', '37', '38', '39',
              '40', '41', '42', '43', '44', '45', '46', '47', '48', '49',
              '50', '51', '52', '53', '54', '55', '56', '57', '58', '59'],

      space: [' 0', ' 1', ' 2', ' 3', ' 4', ' 5', ' 6', ' 7', ' 8', ' 9',
              '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
              '20', '21', '22', '23', '24', '25', '26', '27', '28', '29',
              '30', '31', '32', '33', '34', '35', '36', '37', '38', '39',
              '40', '41', '42', '43', '44', '45', '46', '47', '48', '49',
              '50', '51', '52', '53', '54', '55', '56', '57', '58', '59'],
    };

    var lc = en_US;

    var inspec = false;
    var alt_o  = false;

    var s = '';
    for (var i = 0; i < fmt.length; i++) {
      var c = fmt.charCodeAt(i);
      if (inspec) {
        switch (c) {
        // %%   A literal '%' character
        case 37:
          s += '%';
          break;

        // %a   The abbreviated name of the day of the week according to the
        //      current locale.
        case 97:
          s += lc.weekday.abbr[d.getDay()];
          break;

        // %A   The full name of the day of the week according to the current
        //      locale.
        case 65:
          s += lc.weekday.full[d.getDay()];
          break;

        // %b   The abbreviated month name according to the current locale.
        case 98:
          s += lc.month.abbr[d.getMonth()];
          break;

        // %h   Equivalent to %b.
        case 104:
          s += lc.month.abbr[d.getMonth()];
          break;

        // %B   The full month name according to the current locale.
        case 66:
          s += lc.month.full[d.getMonth()];
          break;

        // %c   The preferred date and time representation for the current
        //      locale.
        case 99:
          s += lc.pref.datetime(d);
          break;

        // %C   The century number (year/100) as a 2-digit integer
        case 67:
          s += parseInt(d.getFullYear() / 100);
          break;

        // %d   The day of the month as a decimal number (range 01 to 31).
        case 100:
          s += lc.zero[d.getDate()];
          break;

        // %D   Equivalent to %m/%d/%y.  (Yecchfor Americans only.  Americans
        //      should note that in other countries %d/%m/%y is rather common.
        //      This means that in international context this format is
        //      ambiguous and should not be used.)
        case 68:
          s += strftime("%m/%d/%y", d);
          break;

        // %e   Like %d, the day of the month as a decimal number, but a
        //      leading zero is replaced by a space.
        case 101:
          s += d.getDate().toString()+(alt_o ? lc.ordinal[d.getDate()] : '');
          break;

        // %E   Modifier: use alternative format, see below.
        case 69:
          // not supported; just skip it
          continue;

        // %F   Equivalent to %Y-%m-%d (the ISO 8601 date format).
        case 70:
          s += strftime("%Y-%m-%d", d);
          break;

        // %G   The ISO 8601 week-based year (see NOTES) with century as a
        //      decimal number.  The 4-digit year corresponding to the ISO
        //      week number (see %V).  This has the same format and value as
        //      %Y, except that if the ISO week number belongs to the previous
        //      or next year, that year is used instead.
        case 71:
          throw "this strftime() does not support '%G'";

        // %g   Like %G, but without century, that is, with a 2-digit year
        //      (00-99).
        case 103:
          throw "this strftime() does not support '%g'";

        // %H   The hour as a decimal number using a 24-hour clock (range 00 to 23).
        case 72:
          s += lc.zero[d.getHours()]
          break;

        // %I   The hour as a decimal number using a 12-hour clock (range 01 to 12)
        case 73:
          s += lc.zero[d.getHours() % 12 == 0 ? 12 : d.getHours() % 12];
          break;

        // %j   The day of the year as a decimal number (range 001 to 366).
        case 106:
          throw "this strftime() does not support '%j'";

        // %k   The hour (24-hour clock) as a decimal number (range 0 to 23);
        //      single digits are preceded by a blank.  (See also %H.)
        case 107:
          s += lc.space[d.getHours()];
          break;

        // %l   The hour (12-hour clock) as a decimal number (range 1 to 12);
        //      single digits are preceded by a blank.  (See also %I.)
        case 108:
          s += lc.space[d.getHours() % 12 == 0 ? 12 : d.getHours() % 12];
          break;

        // %m   The month as a decimal number (range 01 to 12).
        case 109:
          s += lc.zero[d.getMonth()+1];
          break;

        // %M   The minute as a decimal number (range 00 to 59).
        case 77:
          s += lc.zero[d.getMinutes()];
          break;

        // %n   A newline character.
        case 110:
          s += "\n";
          break;

        // %O   Modifier: use alternative format, see below.
        case 79:
          alt_o = true;
          continue;

        // %p   Either "AM" or "PM" according to the given time value, or the
        //      corresponding strings for the current locale.  Noon is treated
        //      as "PM" and midnight as "AM".
        case 112:
          s += (d.getHours() < 12 ? lc.AM : lc.PM);
          break;

        // %P   Like %p but in lowercase: "am" or "pm" or a corresponding
        //      string for the current locale.
        case 80:
          s += (d.getHours() < 12 ? lc.am : lc.pm);
          break;

        // %r   The time in a.m. or p.m. notation.  In the POSIX locale this
        //      is equivalent to %I:%M:%S %p.
        case 114:
          s += lc.zero[d.getHours() % 12 == 0 ? 12 : d.getHours() % 12] + ":" +
               lc.zero[d.getMinutes()]                                  + ":" +
               lc.zero[d.getSeconds()]                                  + " " +
               (d.getHours() < 12 ? lc.AM : lc.PM);
          break;

        // %R   The time in 24-hour notation (%H:%M).  For a version
        //      including the seconds, see %T below.
        case 82:
          s += lc.zero[d.getHours()] + ":" +
               lc.zero[d.getMinutes()];
          break;

        // %s   The number of seconds since the Epoch,
        //      1970-01-01 00:00:00+0000 (UTC).
        case 115:
          s += d.getTime().toString();
          break;

        // %S   The second as a decimal number (range 00 to 60).  (The range
        //      is up to 60 to allow for occasional leap seconds.)
        case 83:
          s += lc.zero[d.getSeconds()];
          break;

        // %t   A tab character.
        case 116:
          s += "\t";
          break;

        // %T   The time in 24-hour notation (%H:%M:%S).
        case 84:
          s += lc.zero[d.getHours()]   + ":" +
               lc.zero[d.getMinutes()] + ":" +
               lc.zero[d.getSeconds()];
          break;

        // %u   The day of the week as a decimal, range 1 to 7, Monday being 1.
        //       See also %w.
        case 117:
          var wday = d.getDay();
          if (wday == 0) { wday = 7 };
          s += (wday).toString()+(alt_o ? lc.ordinal[wday] : '');
          break;

        // %U   The week number of the current year as a decimal number, range
        //      00 to 53, starting with the first Sunday as the first day of
        //      week 01.  See also %V and %W.
        case 85:
          throw "this strftime() does not support '%U'";

        // %V   The ISO 8601 week number (see NOTES) of the current year as a
        //      decimal number, range 01 to 53, where week 1 is the first week
        //      that has at least 4 days in the new year.  See also %U and %W.
        case 86:
          throw "this strftime() does not support '%V'";

        // %w   The day of the week as a decimal, range 0 to 6, Sunday being 0
        //      See also %u.
        case 119:
          s += (d.getDay()).toString();
          break;

        // %W   The week number of the current year as a decimal number, range
        //      00 to 53, starting with the first Monday as the first day of
        //      week 01.
        case 87:
          throw "this strftime() does not support '%W'";

        // %x   The preferred date representation for the current locale
        //      without the time.
        case 120:
          s += lc.pref.date(d);
          break;

        // %X   The preferred time representation for the current locale
        //      without the date.
        case 88:
          s += lc.pref.time(d);
          break;

        // %y   The year as a decimal number without a century (range 00 to 99).
        case 121:
          s += lc.zero[d.getFullYear() % 100];
          break;

        // %Y   The year as a decimal number including the century.
        case 89:
          s += d.getFullYear();
          break;

        // %z   The +hhmm or -hhmm numeric timezone (that is, the hour and
        //      minute offset from UTC).
        case 122:
          throw "this strftime() does not support '%z'";

        // %Z   The timezone name or abbreviation.
        case 90:
          throw "this strftime() does not support '%Z'";

        default:
          throw "unrecognized strftime sequence '%"+fmt[i]+"'";
        }

        inspec = false;
        alt_o  = false;
        continue;
      }

      if (c == 37) { // %
        inspec = true
        continue;
      }

      s += fmt[i];
    }
    return s;
  };

  Lens.strftime = strftime;
  window.strftime = strftime;
})();

$$--GLUE--$$
.\web\index.html
$$--GLUE--$$
<html>
<head>
	<meta charset="UTF-8">
	<title>Doomsday</title>
  <link rel='stylesheet' type='text/css' href="web/assets/fonts.css">
  <link rel='stylesheet' type='text/css' href='web/assets/stylesheet.css'>
</head>
<body>
	<div id="navbar" class="sticky">
		<div class="navbar-content navbar-border navbar-button" id="hamburger-box">
			<svg id="hamburger" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" viewBox="0 0 201 146.17"><defs><style>.cls-1{fill:#ffffff;stroke:#fff;stroke-miterlimit:10;}</style></defs><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><rect class="cls-1" x="0.5" y="0.5" width="200" height="29.27"/><rect class="cls-1" x="0.5" y="59.04" width="200" height="29.27"/><rect class="cls-1" x="0.5" y="116.4" width="200" height="29.27"/></g></g></svg>
		</div>
		<div class="navbar-content navbar-border" id="logo-box">
			<div id="logo">doomsday</div>
		</div>
		<div class="navbar-content">
			<div id="subtitle">an x509 monitoring tool</div>
		</div>
	</div>

	<div id="viewport-container">
		<div id="hamburger-menu" class="sticky navbar-border">
			<div class="hamburger-menu-button navbar-button" id="logout-button">logout</div>
		</div>
		<div id="viewport">
			<div id="login"></div>
			<div id="certs"></div>
		</div>
	</div>

	<script src="web/assets/jquery-3.5.1.min.js"></script>
	<script src="web/assets/lens.js"></script>

	<script type="text/html" id="template:login-page">
		<div id="login-page-container">
			<div id="login-box">
				<form id="login-form">
					<div class="login-text-box">
						<label for="login-form-username">Username</label>
						<input type="text"
						       name="username"
									 id="login-form-username-input"
						/>
					</div>
					<div class="login-text-box">
						<label for="login-form-password">Password</label>
						<input type="password"
						       name="password"
						       id="login-form-password-input"
						/>
					</div>
					<div class="login-button-box">
						<input type="submit" id="login-form-submit-button" value="sign in"/>
					</div>
				</form>
				[[ if (typeof _.error_message !== 'undefined') { ]]
					<div class="login-error">[[= _.error_message ]]</div>
				[[ } ]]
			</div>
		</div>
	</script>

	<script type="text/html" id="template:no-certs-page">
		<div id="no-cert-container">
		  <div class="no-cert-textbox">
		    No Certificates Are Expiring Soon
			</div>
		</div>
		<div class="center-box">
			<button id="certs-show-more" style="position:relative;top:30vh">show all</button>
		</div>
	</script>

	<script type="text/html" id="template:cert-card-header">
		[[
			if (_.value == "") {
				_.value = "<em>(not provided)</em>"
			}
		]]
		<div class="certs-content-header">[[= _.value ]]</div>
	</script>

	<script type="text/html" id="template:cert-card-path-list">
		<div class="certs-content-label">PATHS</div>
		[[
			var backends = [];
			_.paths.forEach(function(path) {
			  var backendFound = false;
			  var i = 0;
				for (; i < backends.length; i++) {
					if (path.backend == backends[i].name) {
						backendFound = true;
					  backends[i].paths.push(path.location);
						break;
					}
				}

				if (!backendFound) {
					backends.push({name: path.backend, paths: [path.location]});
				}
			});

			backends.sort( (x, y) => (x.name < y.name ? -1 : 1) );
			backends.forEach(function(b, i) {
		]]
		<div class="certs-content-path-backend-container">
			<div class="certs-content-label certs-content-backend-label">[[= lens.escapeHTML(b.name) ]]</div>
			<div class="certs-content-path-backend-paths-container">
		[[
				backends[i].paths.sort();
		]]
		    <div class="certs-content-value">[[= lens.escapeHTML(backends[i].paths[0]) ]]</div>
		[[
				backends[i].paths.slice(1).forEach(function(path) {
		]]
					<div class="horizontal-line"></div>
					<div class="certs-content-value">[[= lens.escapeHTML(path) ]]</div>
		[[
				});
		]]
		  </div>
		</div>
		[[
			});
		]]
	</script>

	<script type="text/html" id="template:cert-card-line">
		[[
		  if (!Array.isArray(_.value)) {
				_.value = [ _.value ];
		  }
		]]
		<div class="certs-content-label">[[= _.label ]]</div>
		<div class="certs-content-value">[[= _.value[0] ]]</div>
		[[
		if (_.value.length > 1) {
		  _.value.slice(1).forEach(function(v) {
		]]
		    <div class="horizontal-line"></div>
			  <div class="certs-content-value">[[= v ]]</div>
		[[
		  });
		}
		]]
	</script>

	<script type="text/html" id="template:cert-card">
		<div class="cert-grid-container">
			[[
				expired = new Date().getTime()/1000 > _.cert.not_after;
				var expiredClass="";
				if (expired) { expiredClass = " expired-card"; }
			]]
			<div class="cert-card[[= expiredClass ]]" [[= (expired ? "" : 'style="background-color: rgb(' + _.color[0] + ',' + _.color[1] + ',' + _.color[2] + ');"') ]] >
			  [[ lens.include("cert-card-header", { label: "COMMON NAME", value: lens.escapeHTML(lens.maybe(_.cert.common_name, "not provided")) }); ]]
				<div class="certs-content-body">
				[[
				    timefmt = Lens.strftime("%a, %b %d %Y at %I:%M %P", _.cert.not_after );
				    var label = "NOT AFTER";
						if (expired) {
						  label = "REST IN PEACE";
							//timefmt = "<s>"+timefmt+"</s> EXPIRED";
						}
						lens.include("cert-card-line", { label: label, value: timefmt });
						lens.include("cert-card-path-list", { paths: _.cert.paths });
				]]
					</div>
			</div>
		</div>
	</script>

	<script type="text/html" id="template:cert-list">
		<div class="cert-list">
			<div class="cert-list-footer-container">
				<div class="cert-list-footer-left-buffer"></div>
				<div class="cert-list-footer-timeline-container">
					<div class="cert-list-footer-timeline-label">[[= _.header ]]</div>
				</div>
			</div>
			<div class="cert-list-body">
				<div class="cert-list-body-card-container">
				[[
					_.certs.forEach(function(v) {
						lens.include("cert-card", { cert: v, color: _.color });
					});
				]]
				</div>
				<div class="cert-list-body-timeline-container">
					<div class="cert-list-body-line-taper-in"></div>
					<div class="cert-list-body-timeline-line"></div>
					<div class="cert-list-body-line-taper-out"></div>
				</div>
			</div>
		</div>
	</script>

	<script type="text/html" id="template:cert-list-group">
		[[
			_.lists.forEach(function(v, i) {
			  if (i == _.lists.length - 1) {
					v.skip_lower_line = true;
				}

				lens.include("cert-list", v);
			});
		]]
		<div class="center-box">
			<button id="certs-show-more">show all</button>
		</div>
	</script>

	<script type="application/javascript" src="web/assets/js/doomsday.js"></script>
</body>
</html>

$$--GLUE--$$
.\web\package-lock.json
$$--GLUE--$$
{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "@types/jquery": {
      "version": "3.5.14",
      "resolved": "https://registry.npmjs.org/@types/jquery/-/jquery-3.5.14.tgz",
      "integrity": "sha512-X1gtMRMbziVQkErhTQmSe2jFwwENA/Zr+PprCkF63vFq+Yt5PZ4AlKqgmeNlwgn7dhsXEK888eIW2520EpC+xg==",
      "requires": {
        "@types/sizzle": "*"
      }
    },
    "@types/sizzle": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/@types/sizzle/-/sizzle-2.3.3.tgz",
      "integrity": "sha512-JYM8x9EGF163bEyhdJBpR2QX1R5naCJHC8ucJylJ3w9/CVBaskdQ8WqBf8MmQrd1kRvp/a4TS8HJ+bxzR7ZJYQ=="
    }
  }
}

$$--GLUE--$$
.\web\package.json
$$--GLUE--$$
{
  "dependencies": {
    "@types/jquery": "^3.5.1",
    "@types/sizzle": "^2.3.3"
  }
}

$$--GLUE--$$
.\web\stylesheet.css
$$--GLUE--$$
#viewport {
	display: flex;
	width: 100%;
	height: calc(100vh - 60px);
	overflow: auto;
	background: repeating-linear-gradient(
		45deg,
		rgba(0, 0, 0, 0),
		rgba(0, 0, 0, 0) 60px,
		rgba(0, 0, 0, 0.15) 60px,
		rgba(0, 0, 0, 0.15) 120px
  );
	margin-top: 60px;
	overflow-y: scroll;
}

#login {
	height: 100%;
	width: 100%;
	display: none;
}

#login-page-container {
	height: 100%;
	width: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
}

#login-box {
	background-color: #252525;
	border-radius: 14px;
	display: flex;
	flex-wrap: wrap;
	justify-content: center;
	align-content: center;
	width: 400px;
}

#login-box label {
	color: white;
	width: 100%;
}

#login-form {
	display: flex;
	flex-wrap: wrap;
	justify-content: center;
	align-content: center;
	margin: 1em;
	width: 100%;
}

.center-box {
	display: flex;
	justify-content: center;
	align-content: center;
	width: 100%;
}

#certs-show-more {
	font-size: 24px;
	font-weight: bold;
	font-family: inherit;
	color: white;
	margin: 1em;
	padding: 0.5em;
	border-color: white;
	border-style: solid;
	border-radius: 8px;
	border-width: thick;
	background-color: rgba(0, 0, 0, 0.4);
  user-select: none;
}

#certs-show-more:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

#certs-show-more:active {
  background-color: rgba(255, 255, 255, 0.2);
}

#certs-show-more:disabled {
	background-color: rgba(255, 255, 255, 0.0)
}

.login-text-box {
	margin: 0.75em 1.5em;
	width: 100%;
	display: flex;
	flex-wrap: wrap;
}

.login-text-box input[type=text], input[type=password] {
	font-size: 20px;
	width: 100%;
	border-radius: 6px;
}

.login-button-box {
	margin: 0.4em;
	display: flex;
	justify-content: center;
	width: 100%;
}

.login-button-box input[type=submit] {
	font-size: 20px;
	font-family: inherit;
	border-radius: 6px;
	padding: 0em 1em;
}

.login-error {
	margin: 1em;
	margin-top: 0;
	padding: 0.2em;
	font-size: 16px;
	width: 90%;
	text-align: center;
	border-radius: 6px;
	background-color: rgb(229, 53, 69);
}

#navbar {
	background-color: #252525;
	display: flex;
	align-content: center;
	font-size: 40;
	height: 60px;
	border-bottom: solid rgba(0,0,0,0.4) thin;
	z-index: 100;
	top: 0;
	width: 100%;
}

#navbar-left-buffer {
	width: 0px;
}

.navbar-content {
	display: flex;
	align-items: center;
	justify-content: center;
	padding-left: 15px;
	padding-right: 15px;
}

.navbar-border {
	border-right-color: rgba(255, 255, 255, 0.3);
	border-right-style: solid;
	border-right-width: thin;
}

.sticky {
	position: fixed;
}

#navbar #logo {
  color: white;
	font-size: 40;
	position: relative;
	top: -4px;
	-webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  font-family: 'Walter Turncoat', 'Pangolin', 'Verdana';
}

#hamburger {
	height: 25px;
	width: 25px;
	flex: 1 1 auto;
}

#hamburger-box {
	display: flex;
	align-items: center;
}

.navbar-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.navbar-button:active {
  background-color: rgba(255, 255, 255, 0.2);
}

#hamburger-menu {
	background-color: rgba(37, 37, 37, 0.9);
	height: calc(100% - 60px);
	width: 250px;
	z-index: 100;
	top: 60px;
	left: -251px;
	display: inline-block;
}

.hamburger-menu-button {
	display: flex;
	align-items: center;
	align-content: center;
	justify-content: center;
	height: 30px;
	padding: 5px 20px 5px 20px;
	font-size: 24px;
	color: white;
	border-style: solid none solid none;
	border-width: thin;
	border-color: rgba(255, 255, 255, 0.3);
	-webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
	background-color: #252525;
}

.hamburger-menu-button-inactive {
	display: flex;
	align-items: center;
	align-content: center;
	justify-content: center;
	height: 30px;
	padding: 5px 20px 5px 20px;
	font-size: 24px;
	color: grey;
	border-style: solid none solid none;
	border-width: thin;
	border-color: rgba(255, 255, 255, 0.3);
	-webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
	background-color: #252525;
}

#navbar #subtitle {
	color: white;
	font-size: 20;
	-webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

#certs {
	margin-top: 20px;
  flex: 1 1 auto;
}

#no-cert-container {
	display: flex;
}

.no-cert-textbox {
	border-style: solid;
	border-radius: 8px;
	border-color: white;
	border-width: thick;
	font-weight: bold;
	background-color: rgba(0, 0, 0, 0.15);
	color: white;
	font-size: 4vw;
	padding: 0.75em;
	position: relative;
	top: 30vh;
	margin: auto;
}

body {
	margin: 0px;
	background-color: #444444;
	overflow: hidden;
}

div {
	font-family: "Pangolin", "Walter Turncoat", "Verdana";
	color: rgba(0,0,0,.8);
}

.cert-grid-container {
	width: 100%;
}

.certs-content-header {
	background-color: rgba(0,0,0,.0700);
	border-radius: 8px 8px 0px 0px;
	border-bottom-style: solid;
	border-bottom-color: rgba(0,0,0,0.0500);
	border-width: thin;
	text-align: center;
	font-size: 24;
	padding: 0.3em 0em;
	font-weight: bold;
	color: #FFFFFF;
}

.certs-content-body {
	padding: 0.5em 1em;
}

.cert-list-footer-container {
  margin: 4px 8px 4px 0;
	display: flex;
}

.cert-list-footer-left-buffer {
	align-self: center;
	align-content: center;
	display: flex;
	flex: 1 1 auto;
}

.cert-list-footer-timeline-label {
	color: white;
	text-align: right;
	font-size: 20px;
	-webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}


.cert-list-body-timeline-container {
	position: relative;
	margin-right: 10px;
}

.cert-list-body-line-taper-in {
	height: 40px;
	width: 4px;
	position: relative;
	background-image: linear-gradient(to top, rgba(255,255,255,1), rgba(0,0,0,0));
}

.cert-list-body-timeline-line {
	width: 4px;
	position: absolute;
	height: calc(100% - 80px);
	background-color: white;
}

.cert-list-body-line-taper-out {
	height: 40px;
	width: 4px;
	position: absolute;
	top: calc(100% - 40px);
	background-image: linear-gradient(to bottom, rgba(255,255,255,1), rgba(0,0,0,0));
}

.cert-list-body {
	display: flex;
}

.cert-list-body-card-container {
	flex: 1 1 auto;
}

.cert-list-body-card-container {
  display: flex;
	flex-wrap: wrap;
	flex: 1 1 auto;
}

.cert-list {
	width: 100%;
}

.cert-card {
	border-style: solid;
	border-width: thin;
	border-color: rgba(255,255,255, 0.1) rgba(0, 0, 0, 0.0300) rgba(0, 0, 0, 0.300) rgba(255, 255, 255, 0.1);
	margin: 0.5em 1em;
	border-radius: 8px;
	box-shadow: 7px 5px rgba(0,0,0,0.450);
}

.certs-content-label {
	font-weight: bold;
	font-size: 12px;
	color: #ffffff;
	margin-top: 0.5em;
}

.certs-content-value {
	padding-left: 8px;
	margin-bottom: 0.1em;
	font-size: 18;
	word-wrap: break-word;
}

.certs-content-path-backend-container {
	margin-top: 0.35em;
	margin-left: 0em;
	background-color: rgba(0, 0, 0, 0.05);
	border-style: solid;
	border-width: thin;
	border-color: rgba(0, 0, 0, 0.1) rgba(255, 255, 255, 0.1) rgba(255, 255, 255, 0.1) rgba(0, 0, 0, 0.1) ;
	border-radius: 8px;
	padding: 0.5em;
}

.certs-content-path-backend-container .certs-content-label {
	margin-top: 0.25em;
	font-size: 12px;
	font-weight: bold;
}

.certs-content-path-backend-container .certs-content-value {
	margin-left: 0;
	padding-left: 0;
}

.horizontal-line {
	display: block;
	height: 2px;
  width: 95%;
	margin: auto;
	background-color: rgba(0,0,0,0.100);
}

.cert-list-footer-left-buffer .horizontal-line {
	width: 100%;
	background-color: white;
	height: 4px;
}

.horizontal-line-taper {
	height: 4px;
	width: 40px;
	position: relative;
	margin-right: 1%;
	background-image: linear-gradient(to right, rgba(255,255,255,1), rgba(0,0,0,0));
}

.expired-card {
	background-color: #252525;
	box-shadow: 7px 5px rgb(229, 53, 69);
	border-color: rgba(255, 255, 255, 0.25) rgba(0, 0, 0, 0.7) rgba(0, 0, 0, 0.7) rgba(255, 255, 255, 0.25) !important;
}

.expired-card .certs-content-header {
  border-color: rgba(255, 255, 255, 0.1);
}

.expired-card .certs-content-value {
	color: rgb(229, 53, 69);
}

@media only screen and (min-width: 600px) {
	#navbar #subtitle {
		 display: inline-block;
	}
}

@media only screen and (min-width: 1200px) {
	.cert-grid-container {
	  width: 50%;
  }

}

@media only screen and (min-width: 1800px) {
  .cert-grid-container {
	  width: 33.33333%;
  }
}

@media only screen and (min-width: 2400px) {
  .cert-grid-container {
	  width: 25%;
  }
}

@media only screen and (min-width: 3000px) {
  .cert-grid-container {
	  width: 20%;
  }
}

@media only screen and (min-width: 3600px) {
  .cert-grid-container {
	  width: 16.66666%;
  }
}

$$--GLUE--$$
.\web\ts\client.ts
$$--GLUE--$$
/*======================================== *
 * This file defines a Doomsday API client *
 * ========================================*/

/**
 * Enumeration of supported auth methods
 */
enum AuthMethod { NONE, USERPASS };

/**
 * Contains error information returned from an HTTP API call
 */
class APIError {
  readonly error: string;
  readonly code: number;

  constructor(readonly errorMessage: string, readonly returnCode: number) {
    this.error = errorMessage;
    this.code = returnCode;
  }
}

/**
 * An HTTP Client to the Doomsday API
 */
class Doomsday {
  private doRequest(method: string, path: string, data?: object): Promise<any> {
    return fetch(path, {
      method:      method,
      credentials: "same-origin",
      headers:     {
        "Content-Type": "application/json"
      },
      body: data ? JSON.stringify(data) : undefined,
    })
    .catch(
      () => { throw new APIError("Unexpected fetch error", 0) },
    )
    .then(
      resp => { 
        if (resp.ok) { return resp.json(); }
        throw new APIError(resp.statusText, resp.status);
      }
    ).catch(
      e => {
        if (e instanceof APIError) { throw e; }
        throw new APIError("JSON parsing failed", 0);
      }
    );
  }

  fetchAuthType(): Promise<AuthMethod> {
    return this.doRequest("GET", "/v1/info")
      .then(
        data => (data.auth_type == "Userpass" ? AuthMethod.USERPASS : AuthMethod.NONE)
      );
  }

  authUser(username: string, password: string): Promise<void> {
    return this.doRequest("POST", "/v1/auth", {
      username: username,
      password: password
    });
  }

  fetchCerts(): Promise<Array<Certificate>> {
    return this.doRequest("GET", "/v1/cache")
      .then(data => {
        let ret: Array<Certificate> = [];
        for (let cert of data.content) {
          ret.push(($.extend(new Certificate(), cert) as Certificate))
        }
        return ret;
      });
  }
}

class Certificate {
  common_name: string;
  not_after: number;
  paths: Array<CertificateStoragePath>;

  get commonName(): string { return this.common_name; }
  get notAfter(): number { return this.not_after; }
}

class CertificateStoragePath {
  backend: string;
  location: string;
}

$$--GLUE--$$
.\web\ts\color.ts
$$--GLUE--$$
class Color {
  readonly red: number;
  readonly green: number;
  readonly blue: number;
  constructor(red: number, green: number, blue: number) {
    this.red = red;
    this.green = green;
    this.blue = blue;
  }
  get 0(): number { return this.red; }
  get 1(): number { return this.green; }
  get 2(): number { return this.blue; }
  hex(): string {
    return "#" + this.cAsHex(this.red) + this.cAsHex(this.green) + this.cAsHex(this.blue);
  }

  shift(c2: Color, percent: number): Color {
    return new Color(
      this.red + ((c2.red - this.red) * percent),
      this.green + ((c2.green - this.green) * percent),
      this.blue + ((c2.blue - this.blue) * percent)
    );
  }

  private cAsHex(c: number): string {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;;
  }
}

namespace Colors {
  export const Black = new Color(0, 0, 0);
  export const Red = new Color(229, 53, 69);
  export const Orange = new Color(253, 126, 20);
  export const OrangeYellow = new Color(255, 193, 7);
  export const Yellow = new Color(200, 185, 15);
  export const Green = new Color(40, 167, 69);
}
$$--GLUE--$$
.\web\ts\cookie.ts
$$--GLUE--$$
function getCookie(name: string) {
  let state = 0;
  let length = document.cookie.length;
  let found = false;
  let key = "";
  let value = "";
  function checkKey() {
    if (key == name) {
      found = true;
    } else {
      key = "";
      value = "";
      state = 2;
    }
  }
  for (let i = 0; i < length && !found; i++) {
    let c = document.cookie.charAt(i);
    switch (state) {
      case 0: //parsing from the start of the cookie
        if (c == '=') {
          state = 1;
        } else if (c == ';') {
          value = key;
          key = "";
          checkKey();
        } else {
          key = key + c;
        }
        break;
      case 1: //parsing from after the '=' of a cookie
        if (c == ';') {
          checkKey();
        } else {
          value = value + c;
        }
        break;
      case 2: //chew through whitespace after semicolon
        if (c == '=') {
          key = "";
          state = 1;
        } else if (c == ';') {
          key = "";
          value = "";
          checkKey();
        } else if (c != ' ' && c != '\t') {
          key = c;
          state = 0;
        }
        break;
    }
  }

  if (!found && key != name) {
    value = "";
  }

  return value;
}

function deleteCookie(name: string) {
  document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
}
$$--GLUE--$$
.\web\ts\main.ts
$$--GLUE--$$
/// <reference path="./client.ts"/>
/// <reference path="./pager.ts"/>
/// <reference path="./cookie.ts"/>
/// <reference path="./pages/login.ts"/>
/// <reference path="./pages/certs.ts"/>
/// <reference path="./color.ts"/>

//Because Lens.js adds template to $()
interface JQuery {
	template(template: string, options?: object): any;
}

let NORMAL_HAMBURGER_WIDTH;
let NORMAL_HAMBURGER_HEIGHT;
let HAMBURGER_BOX_PADDING;

$(document).ready(function () {
	let hamburgerBox = $('#hamburger-box');
	NORMAL_HAMBURGER_WIDTH = hamburgerBox.width();
	NORMAL_HAMBURGER_HEIGHT = $('#hamburger').height();
	HAMBURGER_BOX_PADDING = hamburgerBox.innerWidth() - NORMAL_HAMBURGER_WIDTH;

	let doomsday = new Doomsday();
	let pager = new Pager(doomsday);

	doomsday.fetchAuthType()
		.then(authType => {
			if (authType == AuthMethod.NONE) {
				let logout_button = $('#logout-button');
				logout_button.addClass('hamburger-menu-button-inactive');
				logout_button.removeClass('navbar-button hamburger-menu-button');
				logout_button.mouseover(function () { logout_button.text('auth is turned off'); });
				logout_button.mouseout(function () { logout_button.text('logout'); });
			} else {
				$('#logout-button').click(function () {
					closeHamburgerMenu();
					deleteCookie('doomsday-token');
					pager.display(new LoginPage());
				});
			}
			if (authType == AuthMethod.USERPASS && getCookie('doomsday-token') == "") {
				pager.display(new LoginPage());
			} else {
				pager.display(new DashboardPage());
			}
		})
		.catch((e: APIError) => {
			console.log(`Something went wrong: ${e.errorMessage}`);
		});
});

const FRAMERATE = 42;
const FRAME_INTERVAL = 1000 / FRAMERATE;

const NO_ANIM = -1;

let hamburgerMenuOpen = false;

let currentHamburgerMenuOpenness = 0;

function setHamburgerMenuOpenness(percentage: number) {
	let menu = $('#hamburger-menu');
	//The +1 is for the 1px wide border
	let menuWidth = menu.innerWidth() + 1;
	let desiredShift = menuWidth * percentage;

	menu.css('left', (-menuWidth + desiredShift) + "px");

	let boxWidth = Math.max(desiredShift - (1 + HAMBURGER_BOX_PADDING), NORMAL_HAMBURGER_WIDTH);
	let boxHeight = NORMAL_HAMBURGER_HEIGHT - (percentage * (NORMAL_HAMBURGER_HEIGHT * 0.1));
	$('#hamburger-box').css('width', boxWidth + "px");
	$('#hamburger').css('height', boxHeight + "px");
	currentHamburgerMenuOpenness = percentage;
}

let menuOpenAnimID = NO_ANIM;

function hamburgerMenuSlide(start: number, end: number) {
	if (menuOpenAnimID != NO_ANIM) {
		clearInterval(menuOpenAnimID);
	}
	let duration = 0.2; //in seconds
	let totalDelta = end - start;
	let lastAnimTime = new Date().getTime();
	return function () {
		let now = new Date().getTime();
		let timeDelta = now - lastAnimTime;
		let updatePercentage = (duration * 1000) / timeDelta;
		let frameDelta = totalDelta / updatePercentage;
		lastAnimTime = now;

		let desiredOpenness = currentHamburgerMenuOpenness + frameDelta;
		if ((totalDelta >= 0 && desiredOpenness >= end) || (totalDelta < 0 && desiredOpenness <= end)) {
			desiredOpenness = end;
			clearInterval(menuOpenAnimID);
			menuOpenAnimID = NO_ANIM;
		}

		setHamburgerMenuOpenness(desiredOpenness);
	};
}

function openHamburgerMenu() {
	menuOpenAnimID = setInterval(hamburgerMenuSlide(0, 1), FRAME_INTERVAL);
	hamburgerMenuOpen = true;
}

function closeHamburgerMenu() {
	menuOpenAnimID = setInterval(hamburgerMenuSlide(1, 0), FRAME_INTERVAL);
	hamburgerMenuOpen = false;
}

function toggleHamburgerMenu() {
	if (hamburgerMenuOpen) {
		closeHamburgerMenu();
	} else {
		openHamburgerMenu();
	}
}

$('#hamburger-box').click(function () {
	toggleHamburgerMenu();
});
$$--GLUE--$$
.\web\ts\pager.ts
$$--GLUE--$$
/// <reference path="./client.ts"/>
class Pager {
  private ctx: PageContext;
  private curPage: Page;

  constructor(client: Doomsday) {
    this.ctx = {
      client: client,
      hamburgerMenu: $("#hamburger-box"),
      pager: this
    };
  }

  display(page: Page): void {
    if (this.curPage != null) {
      this.curPage.teardown();
    }

    this.curPage = page;
    page.setContext(this.ctx);
    if (page.settings && page.settings.hideHamburgerMenu) {
      this.ctx.hamburgerMenu.hide()
    } else {
      this.ctx.hamburgerMenu.show();
    }

    page.initialize();
  }
}

class PageContext {
  client: Doomsday;
  hamburgerMenu: JQuery;
  pager: Pager;
}


interface Page {
  settings: PageSettings;
  initialize(...args: any): void;
  teardown(): void;
  setContext(ctx: PageContext): void;
}

abstract class PageBase implements Page {
  protected _settings: PageSettings;
  protected ctx: PageContext;

  abstract initialize(): void;
  abstract teardown(): void;
  setContext(ctx: PageContext) {
    this.ctx = ctx;
  }
  get settings(): PageSettings {
    return this._settings;
  }
}

class PageSettings {
  hideHamburgerMenu: boolean;
}
$$--GLUE--$$
.\web\ts\pages\certs.ts
$$--GLUE--$$
/// <reference path="../color.ts"/>
class DashboardPage extends PageBase {
  private certUpdateID: number;
  private certsElement: JQuery;
  private showMoreButton: JQuery;
  private certs: CertificateList;
  private shouldShowAll: boolean;

  static readonly DEFAULT_EXPIRY_CUTOFF: number = 7776000;
  constructor() {
    super();
    this.certUpdateID = -1;
    this.certsElement = $("#certs");
  }

  initialize(): void {
    this.certsElement.show();
    this.certs = new CertificateList();

    this.updateCertList();
  }

  teardown(): void {
    clearTimeout(this.certUpdateID);
    this.certUpdateID = -1;
    this.certsElement.hide();
    this.showMoreButton.off();
  }

  private updateCertList() {
    this.ctx.client.fetchCerts()
      .then((content: Array<Certificate>) => {
        this.certs = new CertificateList(content);
        this.repaint();
        this.certUpdateID = setTimeout(this.updateCertList.bind(this), 60 * 1000);
      })
      .catch(e => {
        if (e.code == 401) {
          deleteCookie('doomsday-token');
          this.ctx.pager.display(new LoginPage("Your session has expired"));
        } else {
          this.ctx.pager.display(new LoginPage("Something went wrong!"));
          console.log(`Something went wrong: ${e.errorMessage}`);
        }
      });
  }

  private repaint() {
    let now = new Date().getTime() / 1000;
    let lists = [];
    let certsToDisplay = this.certs;
    if (!this.shouldShowAll) {
      certsToDisplay = this.certs.expiresWithin(DashboardPage.DEFAULT_EXPIRY_CUTOFF)
    }
    for (let cert of certsToDisplay) {
      if (lists.length == 0 || cert.notAfter > lists[lists.length - 1].cutoff) {
        let maxDays = Math.max(0, Math.ceil((cert.not_after - now) / 86400));
        let label = this.durationString(maxDays - 1);
        lists.push({
          header: label,
          cutoff: now + (maxDays * 86400),
          color: this.cardColor(maxDays - 1),
          certs: [cert]
        });
      } else {
        lists[lists.length - 1].certs.push(cert);
      }
    }

    if (lists.length == 0) {
      this.certsElement.template("no-certs-page");
    } else {
      this.certsElement.template("cert-list-group", { lists: lists });
      this.certsElement.show();
    }
    this.showMoreButton = $("#certs-show-more");
    this.showMoreButton.on("click", (e: JQuery.Event) => {
      e.preventDefault();
      this.showMoreButton.prop("disabled", true);
      this.showMoreButton.html("working...");
      this.shouldShowAll = !this.shouldShowAll;
      this.repaint();
      this.showMoreButton = $("#certs-show-more");
      this.showMoreButton.html("show " + (this.shouldShowAll ? "less" : "all"));
      this.showMoreButton.prop("disabled", false);
      return false;
    })
    return;
  }


  private durationString(days: number): string {
    if (days < 0) {
      return "THE DAWN OF TIME";
    } else if (days == 0) {
      return "NOW";
    } else if (days == 1) {
      return "1 DAY";
    } else if (days < 7) {
      return days + " DAYS";
    } else {
      var weeks = Math.floor(days / 7);
      var remaining_days = days - (weeks * 7);
      var ret = weeks + " WEEKS";
      if (weeks == 1) {
        ret = "1 WEEK";
      }
      if (remaining_days > 0) {
        ret = ret + ", " + this.durationString(remaining_days);
      }
      return ret;
    }
  }

  private cardColor(days: number): Color {
    if (days < 0) {
      return Colors.Black;
    } else if (days < 3) {
      return Colors.Red;
    } else if (days < 7) {
      return Colors.Red.shift(Colors.Orange, 1 - ((7 - days) / 4));
    } else if (days < 14) {
      return Colors.Orange.shift(Colors.OrangeYellow, 1 - ((14 - days) / 7));
    } else if (days < 21) {
      return Colors.OrangeYellow.shift(Colors.Yellow, 1 - ((21 - days) / 7));
    } else if (days < 28) {
      return Colors.Yellow.shift(Colors.Green, 1 - ((28 - days) / 7));
    }

    return Colors.Green;
  }
}

/**
 * A list of Certificates
 *
 * @remarks
 * Given input must currently be presented in a sorted order
 */
class CertificateList {
  private storage: Array<Certificate>
  private expMax: number; //inclusive

  constructor(initial?: Array<Certificate>) {
    this.storage = [];
    if (initial) {
      this.storage = initial;
    }
  }

  [Symbol.iterator]() {
    const now = new Date().getTime() / 1000;
    const maxUntil: number =
      (typeof this.expMax === 'number' ? this.expMax : Number.MAX_VALUE);
    let idx: number = 0;
    return {
      next: () => {
        let isDone = () => {
          if (idx >= this.storage.length) {
            return true;
          }
          if (this.storage[idx].notAfter - now > maxUntil) {
            return true;
          }
          return false;
        }
        let done: boolean = isDone();
        return {
          done: done,
          value: done ? undefined : this.storage[idx++]
        }
      }
    }
  }

  get length(): number { return this.storage.length; }

  /**
   * Returns a new CertificateStore which, when iterated over, will only yield
   * the elements of the CertificateStore which expire within the given timespan.
   *
   * @param duration Number of seconds from now a cert must expire within to
   *   be returned.
   */
  expiresWithin(duration: number): CertificateList {
    let ret: CertificateList = new CertificateList(this.storage);
    ret.expMax = duration;
    return ret;
  }
}

$$--GLUE--$$
.\web\ts\pages\login.ts
$$--GLUE--$$
class LoginPage extends PageBase {
  private readonly message;
  private login: JQuery;
  private loginForm: JQuery;
  private loginFormUsername: JQuery;
  private loginFormPassword: JQuery;
  constructor(message?: string) {
    super();
    this.message = message;
    this._settings = {
      hideHamburgerMenu: true
    };
  }

  initialize(): void {
    var templateParams: { error_message?: string } = {};
    if (this.message) {
      templateParams.error_message = this.message;
    }
    this.login = $("#login");
    this.login.template("login-page", templateParams);
    this.loginForm = $("#login-form");
    this.loginFormUsername = $("#login-form input[name=username]");
    this.loginFormPassword = $("#login-form input[name=password]");

    this.loginForm.submit(this.getLoginHandler());
    this.login.show();
  }

  teardown(): void {
    this.login.hide();
    this.loginForm.off("submit");
  }

  private getLoginHandler() {
    let self = this;
    return function (e: JQuery.Event) {
      let username = (self.loginFormUsername.val() as string);
      let password = (self.loginFormPassword.val() as string);
      self.loginFormPassword.val("");
      self.ctx.client.authUser(username, password)
        .then(() => {
          self.ctx.pager.display(new DashboardPage());
        })
        .catch(e => {
          if (e.code == 401) {
            self.ctx.pager.display(new LoginPage("The username and password did not match"));
          }
          else {
            self.ctx.pager.display(new LoginPage("Something went wrong!"));
            console.log(`Something went wrong: ${e.errorMessage}`);
          }
        });
      return false;
    }
  }
}
$$--GLUE--$$
.\web\tsconfig.json
$$--GLUE--$$
{
	"compilerOptions": {
		"outFile": "./build/doomsday.js",
		"allowJs": true,
		"target": "es6",
		"removeComments": true
	},
	"include": [
		"./ts/**/*"
	]
}